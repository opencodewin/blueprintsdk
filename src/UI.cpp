#include <UI.h>
#include <BuildInNodes.h> // Which is generated by cmake
#include <imgui_node_editor_internal.h>
#include <iomanip>
#include <utility>
#define THUMBNAIL_COUNT     100
#define THUMBNAIL_HIDDEN    30
#define DEBUG_NODE_DRAWING  0
#define DEBUG_GROUP_NODE    0
extern std::mutex g_Mutex;

inline string to_lower(string s) 
{        
    for(char &c : s)
        c = tolower(c);
    return s;
}

const string titlebar_icons[] = {ICON_NODE_COPY, ICON_NODE_DELETE, ICON_NODE_SETTING, ICON_SAVE_BLUEPRINT};
                                //{"c", "d", "s", "S"};

namespace BluePrint
{
BluePrintStyle BPStyleFromName(string name)
{
    if (name.compare("Default") == 0)
        return BluePrintStyle::BP_Style_BluePrint;
    else if (name.compare("Light") == 0)
        return BluePrintStyle::BP_Style_Light;
    else if (name.compare("Mono") == 0)
        return BluePrintStyle::BP_Style_Mono;
    else if (name.compare("Custom") == 0)
        return BluePrintStyle::BP_Style_Custom;
    else
        return BluePrintStyle::BP_Style_BluePrint;
}

string BPStyleToString(BluePrintStyle style)
{
    switch (style)
    {
        default:                                return "Default";
        case BluePrintStyle::BP_Style_BluePrint:return "Default";
        case BluePrintStyle::BP_Style_Light:    return "Light";
        case BluePrintStyle::BP_Style_Mono:     return "Mono";
        case BluePrintStyle::BP_Style_Custom:   return "Custom";
    }
}
// ---------------------------
// ------[ ContextMenu ]------
// ---------------------------
void ContextMenu::Open(void)
{
    ImGui::OpenPopup("##context-menu");
}

void ContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##context-menu"))
        return;

    //auto blueprint = &UI.m_Document->m_Blueprint;
    auto menuAction = [](Action& action)
    {
#if IMGUI_ICONS
        string ItemTitle = action.GetIcon() + " " + action.GetName();
#else
        string ItemTitle = action.GetName();
#endif
        if (ImGui::MenuItem(ItemTitle.c_str(), nullptr, nullptr, action.IsEnabled()))
        {
            action.Execute();
        }
    };
    if (ImGui::BeginPopup("##context-menu"))
    {
        auto popupPosition = ImGui::GetMousePosOnOpeningCurrentPopup();
        UI.m_PopupMousePos = popupPosition;
        menuAction(UI.m_File_Open);
        ImGui::Separator();
        menuAction(UI.m_File_Import);
        ImGui::Separator();
        if (!UI.m_isChildWindow)
        {
            auto mostRecentlyOpenFiles = ImGui::MostRecentlyUsedList("BluePrintOpenList");
            if (ImGui::BeginMenu(ICON_NODE_OPEN " Open Recent...", !mostRecentlyOpenFiles.GetList().empty()))
            {
                for (auto& entry : mostRecentlyOpenFiles.GetList())
                {
                    string title = string(ICON_NODE_FILE) + " " + entry;
                    if (ImGui::MenuItem(title.c_str()))
                    {
                        UI.File_Open(entry.c_str());
                    }
                }
                ImGui::Separator();
                if (ImGui::MenuItem(ICON_NODE_CLEAR " Clear Recently Opened"))
                    mostRecentlyOpenFiles.Clear();
                ImGui::EndMenu();
            }
            ImGui::Separator();
        }
        if (ImGui::BeginMenu(ICON_BLUEPRINT_STYLE " Set Style"))
        {
            ImGui::Bullet();
            if (ImGui::MenuItem("Default##BluePrintStyle"))
            {
                UI.SetStyle(BluePrintStyle::BP_Style_BluePrint);
                ed::SetTheme(BPStyleToString(BluePrintStyle::BP_Style_BluePrint));
            }
            ImGui::Bullet();
            if (ImGui::MenuItem("Light##BluePrintStyle"))
            {
                UI.SetStyle(BluePrintStyle::BP_Style_Light);
                ed::SetTheme(BPStyleToString(BluePrintStyle::BP_Style_Light));
            }
            ImGui::Bullet();
            if (ImGui::MenuItem("Mono##BluePrintStyle"))
            {
                UI.SetStyle(BluePrintStyle::BP_Style_Mono);
                ed::SetTheme(BPStyleToString(BluePrintStyle::BP_Style_Mono));
            }
            ImGui::EndMenu();
        }
        ImGui::Separator();
        menuAction(UI.m_File_New);
        ImGui::Separator();
        menuAction(UI.m_File_Save);
        ImGui::Separator();
        menuAction(UI.m_File_SaveAs);
        ImGui::Separator();
        menuAction(UI.m_View_ShowFlow);
        ImGui::Separator();
        menuAction(UI.m_View_ZoomToContent);
        ImGui::Separator();
        menuAction(UI.m_View_ZoomToSelection);
        ImGui::Separator();
        menuAction(UI.m_View_ShowMeters);
        ImGui::Separator();
        if (ImGui::BeginMenu(ICON_NEW_NODE " Add Node"))
        {
            UI.CleanStateStorage();
            UI.ShowNewNodeMenu(popupPosition);
            ImGui::EndMenu();
        }
        ImGui::EndPopup();
    }
}

// ---------------------------
// ----[ NodeContextMenu ]----
// ---------------------------
void NodeContextMenu::Open(Node* node/* = nullptr*/)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##node-context-menu-node"), node);
    ImGui::OpenPopup("##node-context-menu");
}

void NodeContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##node-context-menu"))
        return;
    //auto blueprint = &UI.m_Document->m_Blueprint;
    auto storage = ImGui::GetStateStorage();
    auto node = reinterpret_cast<Node*>(storage->GetVoidPtr(ImGui::GetID("##node-context-menu-node")));
    if (!node)
        return;
    ed::ClearSelection();
    ed::SelectNode(node->m_ID);
    auto menuAction = [](Action& action)
    {
        if (ImGui::MenuItem((action.GetIcon() + " " + action.GetName()).c_str(), nullptr, nullptr, action.IsEnabled()))
        {
            action.Execute();
        }
    };
    if (ImGui::BeginPopup("##node-context-menu"))
    {
        menuAction(UI.m_Edit_Cut);
        ImGui::Separator();
        menuAction(UI.m_Edit_Copy);
        ImGui::Separator();
        menuAction(UI.m_Edit_Duplicate);
        ImGui::Separator();
        menuAction(UI.m_Edit_Delete);
        if (node->GetStyle() == NodeStyle::Default)
        {
            ImGui::Separator();
            menuAction(UI.m_Blueprint_BreakPoint);
        }
        ImGui::Separator();
        node->DrawMenuLayout(ImGui::GetCurrentContext());
        ImGui::EndPopup();
    }
}

// --------------------------
// ----[ PinContextMenu ]----
// --------------------------

void PinContextMenu::PinContextMenu::Open(Pin* pin /*= nullptr*/)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##pin-context-menu-pin"), pin);
    ImGui::OpenPopup("##pin-context-menu");
}

void PinContextMenu::PinContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##pin-context-menu"))
        return;

    auto storage = ImGui::GetStateStorage();
    auto pin = reinterpret_cast<Pin*>(storage->GetVoidPtr(ImGui::GetID("##pin-context-menu-pin")));
    if (!pin)
        return;
    /*
    if (ImGui::BeginPopup("##pin-context-menu"))
    {
        ImGui::Bullet();
        if (ImGui::MenuItem("Export", "", &pin->m_Exported))
        {
            ed::SetPinChanged(pin->m_ID);
            UI.File_MarkModified();
        }
        ImGui::EndPopup();
    }
    */
}

// ---------------------------
// ----[ LinkContextMenu ]----
// ---------------------------
void LinkContextMenu::Open(Pin* pin /*= nullptr*/)
{
    // check link is linked with export pin, we don't allow break export link
    if (pin->IsLinkedExportedPin())
        return;

    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##link-context-menu-pin"), pin);
    ImGui::OpenPopup("##link-context-menu");
}

void LinkContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##link-context-menu"))
        return;

    BP* blueprint = &UI.m_Document->m_Blueprint;
    auto storage = ImGui::GetStateStorage();
    auto pin = reinterpret_cast<Pin*>(storage->GetVoidPtr(ImGui::GetID("##link-context-menu-pin")));
    if (ImGui::BeginPopup("##link-context-menu"))
    {
        if (ImGui::MenuItem("Break Link"))
        {
            if (pin && !ed::IsLinkSelected(pin->m_ID))
            {
                ed::DeleteLink(pin->m_ID);
            }
            else
            {
                auto selectedLinks = GetSelectedLinks(blueprint);
                for (auto selectedLink : selectedLinks)
                    ed::DeleteLink(selectedLink->m_ID);
            }
            UI.File_MarkModified();
        }

        ImGui::EndPopup();
    }
}

// ----------------------------
// ----[ NodeSettingDialog ]----
// ----------------------------
void NodeSettingDialog::Open(Node* node)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##setting-node"), node);
    ImGui::OpenPopup("##setting_node_dialog");
}

void NodeSettingDialog::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##setting_node_dialog"))
        return;
    
    auto storage = ImGui::GetStateStorage();
    auto node = reinterpret_cast<Node*>(storage->GetVoidPtr(ImGui::GetID("##setting-node")));
    if (!node)
        return;
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    auto viewport = ImGui::GetWindowViewport();
    ImVec2 center = viewport->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    ImGui::SetNextWindowViewport(viewport->ID);
    ImGuiWindowFlags flags = ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoNav;
    if (node->m_SettingAutoResize) flags |= ImGuiWindowFlags_AlwaysAutoResize;
    if (ImGui::BeginPopupModal("##setting_node_dialog", NULL, flags))
    {
        ImGui::Text("Setting"); ImGui::SameLine();
        ImGui::Text("%" PRI_node "\n", FMT_node(node));
        ImGui::Separator();
        auto changed = node->DrawSettingLayout(ImGui::GetCurrentContext());
        ImGui::Separator();
        if (ImGui::Button("OK", ImVec2(120, 0))) 
        {
            if (changed)
            {
                UI.File_MarkModified();
                ed::SetNodeChanged(node->m_ID);
            }
            ImGui::CloseCurrentPopup();
            if (UI.m_CallBacks.BluePrintOnChanged)
            {
                UI.m_CallBacks.BluePrintOnChanged(BP_CB_SETTING_CHANGED, UI.m_Document->m_Name, UI.m_UserHandle);
            }
        }
        ImGui::EndPopup();
    }
}

// ----------------------------
// ----[ NodeDeleteDialog ]----
// ----------------------------
void NodeDeleteDialog::Open(Node* node /* = nullptr */)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##delete-node"), node);
    ImGui::OpenPopup("##delete_node_dialog");
}

void NodeDeleteDialog::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##delete_node_dialog"))
        return;
    
    auto storage = ImGui::GetStateStorage();
    auto node = reinterpret_cast<Node*>(storage->GetVoidPtr(ImGui::GetID("##delete-node")));
    if (!node)
        return;
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    ImVec2 center = ImGui::GetWindowViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    if (ImGui::BeginPopupModal("##delete_node_dialog", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
    {
        ImGui::TextUnformatted("Delete Node"); ImGui::SameLine(); ImGui::Text("%" PRI_node " ?\n", FMT_node(node));
        ImGui::Separator();
        if (ImGui::Button("OK", ImVec2(120, 0))) 
        {
            ed::DeleteNode(node->m_ID);
            UI.File_MarkModified();
            ImGui::CloseCurrentPopup();
        }
        ImGui::SetItemDefaultFocus();
        ImGui::SameLine();
        if (ImGui::Button("Cancel", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }
        ImGui::EndPopup();
    }
}

void NodeCreateDialog::Open(Pin* fromPin, uint32_t flag)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##create_node_pin"), fromPin);
    if ((flag & BluePrintFlag::BluePrintFlag_Filter) != 0)
    {
        ImGui::OpenPopup("##create_filter_node");
    }
    else if ((flag & BluePrintFlag::BluePrintFlag_Transition) != 0)
    {
        ImGui::OpenPopup("##create_transition_node");
    }
    else if ((flag & BluePrintFlag::BluePrintFlag_System) != 0)
    {
        ImGui::OpenPopup("##create_system_node");
    }
    else
    {
        ImGui::OpenPopup("##create_node");
    }
}

void NodeCreateDialog::Show(BluePrintUI& UI)
{
    std::string create_node_label = "";
    std::string catalog_filter = "";
    if (!ImGui::IsPopupOpen("##create_node") &&
        !ImGui::IsPopupOpen("##create_filter_node") &&
        !ImGui::IsPopupOpen("##create_transition_node") &&
        !ImGui::IsPopupOpen("##create_system_node"))
    {
        UI.m_isNewNodePopuped = false;
        UI.m_newNodeLinkPin = nullptr;
        return;
    }

    if (ImGui::IsPopupOpen("##create_node"))
    {
        create_node_label = "##create_node";
    }
    else if (ImGui::IsPopupOpen("##create_filter_node"))
    {
        create_node_label = "##create_filter_node";
        catalog_filter = "Filter";
        if (!UI.m_Document->m_CatalogFilter.empty())
        {
            catalog_filter += "#" + UI.m_Document->m_CatalogFilter;
        }
    }
    else if (ImGui::IsPopupOpen("##create_transition_node"))
    {
        create_node_label = "##create_transition_node";
        catalog_filter = "Transition";
        if (!UI.m_Document->m_CatalogFilter.empty())
        {
            catalog_filter += "#" + UI.m_Document->m_CatalogFilter;
        }
    }
    else if (ImGui::IsPopupOpen("##create_system_node"))
    {
        create_node_label = "##create_system_node";
        catalog_filter = "System";
    }

    auto storage = ImGui::GetStateStorage();
    auto fromPin = reinterpret_cast<Pin*>(storage->GetVoidPtr(ImGui::GetID("##create_node_pin")));
    
    if (!ImGui::BeginPopup(create_node_label.c_str()))
    {
        UI.m_isNewNodePopuped = false;
        UI.m_newNodeLinkPin = nullptr;
        return;
    }
    
    auto popupPosition = ImGui::GetMousePosOnOpeningCurrentPopup();
    auto node = UI.ShowNewNodeMenu(popupPosition, catalog_filter);
    if (node)
    {
        m_CreatedNode = node;
        m_CreatedLinks.clear();
        if (fromPin)
        {
            // find linked input node
            Node* input_node =  fromPin->m_Node;
            // find linked output node
            Node* output_node = nullptr;
            if (fromPin->GetType() == PinType::Flow)
            {
                Pin* linked_pin = fromPin->GetLink(&UI.m_Document->m_Blueprint);
                if (linked_pin) output_node = linked_pin->m_Node;
            }
            else if (!fromPin->m_LinkFrom.empty())
            {
                Pin* linked_pin = UI.m_Document->m_Blueprint.GetPinFromID(fromPin->m_LinkFrom[0]);
                if (linked_pin) output_node = linked_pin->m_Node;
            }

            if (UI.m_CallBacks.BluePrintOnChanged)
            {
                auto ret = UI.m_CallBacks.BluePrintOnChanged(BP_CB_NODE_INSERT, UI.m_Document->m_Name, UI.m_UserHandle);
                if (ret == BP_CBR_AutoLink)
                {
                    UI.HandleAutoLink(node, fromPin);
                }
            }
        }
        ed::SetNodeChanged(node->m_ID);
    }
    ImGui::EndPopup();
}
} // namespace BluePrint

namespace BluePrint
{
int BluePrintUI::CheckPlugins(const std::vector<std::string>& pluginPaths)
{
    int plugin_number = 0;
    for (auto& plugin_path : pluginPaths)
    {
        std::vector<std::string> plugins, plugin_names;
        std::vector<std::string> node_filter = {"node"};
        std::vector<std::string> pin_filter = {"pin"};
        if (DIR_Iterate(plugin_path, plugins, plugin_names, node_filter, false) == 0)
        {
            plugin_number += plugins.size();
        }
        plugins.clear();
        if (DIR_Iterate(plugin_path, plugins, plugin_names, pin_filter, false) == 0)
        {
            plugin_number += plugins.size();
        }
    }
    return plugin_number;
}

void BluePrintUI::LoadPlugins(const std::vector<std::string>& pluginPaths, int& current_index, std::string& current_message, float& loading_percentage, int expect_count)
{
    // load dynamic node
    auto nodeRegistry = BP::GetNodeRegistry();
    current_index = 0;
    for (auto& plugin_path : pluginPaths)
    {
        std::vector<std::string> plugins, plugin_names;
        std::vector<std::string> node_filter = {"node"};
        std::vector<std::string> pin_filter = {"pin"};
        if (DIR_Iterate(plugin_path, plugins, plugin_names, node_filter, false) == 0)
        {
            LOGI("Load Extra Node %s", plugin_real_path.c_str());
            for (auto node_path : plugins)
            {
                current_index ++;
                if (expect_count > 0) loading_percentage = std::min((float)current_index / (float)expect_count, 1.f);
                auto nodetypeid = nodeRegistry->RegisterNodeType(node_path);
                if (nodetypeid == 0)
                {
                    LOGE("Load Extra Node Failed %s", node_path.c_str());
                    continue;
                }
                auto nodeinfo = nodeRegistry->GetTypeInfo(nodetypeid);
                if (!nodeinfo)
                {
                    LOGE("Load Extra Node Failed %s", node_path.c_str());
                    continue;
                }
                LOGI("Load Extra Node %s(%d.%d.%d.%d)", nodeinfo->m_NodeTypeName.c_str(),
                                                        VERSION_MAJOR(nodeinfo->m_Version), 
                                                        VERSION_MINOR(nodeinfo->m_Version), 
                                                        VERSION_PATCH(nodeinfo->m_Version), 
                                                        VERSION_BUILT(nodeinfo->m_Version));
                current_message = nodeinfo->m_Name;
                std::cout << "Successfully load extra node:" << current_message << std::endl;
            }
        }

        // load dynamic pin
        auto pinexRegistry = BP::GetPinExRegistry();
        plugins.clear(); plugin_names.clear();
        if (DIR_Iterate(plugin_path, plugins, plugin_names, pin_filter, false) == 0)
        {
            current_index ++;
            if (expect_count > 0) loading_percentage = std::min((float)current_index / (float)expect_count, 1.f);
            LOGI("Load Extra PinEx %s", plugin_real_path.c_str());
            for (auto pinex_path : plugins)
            {
                auto pPinexType = pinexRegistry->RegisterPinEx(pinex_path);
                if (pPinexType == nullptr) {
                    LOGE("FAILED to load PinEx from '%s'!", pinex_path.c_str());
                    continue;
                }
                LOGI("Successfully loaded PinEx from '%s'!", pinex_path.c_str());
                current_message = pPinexType->GetName();
            }
        }
    }
}

BluePrintUI::BluePrintUI()
{
    m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(255, 255, 255,  64);
    m_StyleColors[BluePrintStyleColor_TitleBgDummy]         = ImColor(255,   0,   0,  64);
    m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(128, 128, 128, 128);
    m_StyleColors[BluePrintStyleColor_Border]               = ImColor(255, 255, 255,  64);
    m_StyleColors[BluePrintStyleColor_DummyBorder]          = ImColor(255,   0,  32, 200);
    m_StyleColors[BluePrintStyleColor_ToolButton]           = ImColor(255, 255, 255,   0);
    m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor(192, 192, 192, 192);
    m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor(192, 192, 255, 128);
    m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(  0, 255,   0, 128);
    m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  0,   0, 255, 128);
    m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(255,   0,   0, 128);
    m_StyleColors[BluePrintStyleColor_PinVoid]              = ImColor(255, 255, 255, 255);
    m_StyleColors[BluePrintStyleColor_PinAny]               = ImColor(255, 255, 255, 255);
    m_StyleColors[BluePrintStyleColor_PinFlow]              = ImColor(255, 255, 255, 255);
    m_StyleColors[BluePrintStyleColor_PinBool]              = ImColor( 48, 48,  220, 255);
    m_StyleColors[BluePrintStyleColor_PinInt32]             = ImColor( 68, 201, 156, 255);
    m_StyleColors[BluePrintStyleColor_PinInt64]             = ImColor(100,  34,  78, 255);
    m_StyleColors[BluePrintStyleColor_PinFloat]             = ImColor(147, 226,  74, 255);
    m_StyleColors[BluePrintStyleColor_PinDouble]            = ImColor( 72, 113,  37, 255);
    m_StyleColors[BluePrintStyleColor_PinString]            = ImColor(124,  21, 153, 255);
    m_StyleColors[BluePrintStyleColor_PinPoint]             = ImColor(220, 110,  10, 255);
    m_StyleColors[BluePrintStyleColor_PinVector]            = ImColor( 72, 110, 220, 255);
    m_StyleColors[BluePrintStyleColor_PinMat]               = ImColor(220,  21,  21, 255);
    m_StyleColors[BluePrintStyleColor_PinCustom]            = ImColor(208,  64,  64, 255);
}

void BluePrintUI::Initialize(const char * bp_file)
{    
    ImGui::MostRecentlyUsedList::Install(ImGui::GetCurrentContext());

#if !defined(__EMSCRIPTEN__)
    m_Config.SettingsFile = nullptr;
#endif
    InstallDocumentCallbacks();
    m_Editor = ed::CreateEditor(&m_Config);
    ed::SetCurrentEditor(m_Editor);
    m_Document = make_unique<BluePrint::Document>();
    m_Document->m_UserData = this;

    if (bp_file)
    {
        m_Document->Load(bp_file);
        if (m_Document->Load(bp_file) != BP_ERR_NONE)
            CreateNewDocument();
    }

    if (bp_file) m_Document->SetPath(bp_file);
    m_Document->OnMakeCurrent();

    m_DebugOverlay = new DebugOverlay();
    m_DebugOverlay->Init(&m_Document->m_Blueprint);
    std::string theme = ed::GetTheme();
    SetStyle(BPStyleFromName(theme));
    ed::SetCurrentEditor(nullptr);
#if !defined(__EMSCRIPTEN__)
    m_ClipBoard.clear();
#endif
}

void BluePrintUI::Finalize()
{
    ed::SetCurrentEditor(m_Editor);
    if (m_Document) m_Document->Save();
    m_Document = nullptr;
    ed::SetCurrentEditor(nullptr);
    ed::DestroyEditor(m_Editor);
    m_Editor = nullptr;
    if (m_DebugOverlay) { delete m_DebugOverlay; m_DebugOverlay = nullptr; }
#ifdef USE_PLACES_FEATURE
	// save bookmarks
    if (!m_BookMarkPath.empty())
    {
        std::ofstream configFileWriter(m_BookMarkPath, std::ios::out);
        if (!configFileWriter.bad())
        {
            configFileWriter << ImGuiFileDialog::Instance()->SerializePlaces();
            configFileWriter.close();
        }
    }
#endif
}

void BluePrintUI::SetStyle(enum BluePrintStyle style)
{
    auto& io = ImGui::GetIO();
    switch (style)
    {
        case BluePrintStyle::BP_Style_BluePrint:
        {
            ImGui::StyleColorsDark();
            if (m_Document) m_Document->m_Blueprint.SetStyleLight(false);
            ImGuiFileDialog::Instance()->SetDarkStyle();
            m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(255, 255, 255,  64);
            m_StyleColors[BluePrintStyleColor_TitleBgDummy]         = ImColor(255,   0,   0,  64);
            m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(128, 128, 128, 128);
            m_StyleColors[BluePrintStyleColor_Border]               = ImColor(255, 255, 255,  64);
            m_StyleColors[BluePrintStyleColor_DummyBorder]          = ImColor(255,   0,  32, 200);
            m_StyleColors[BluePrintStyleColor_ToolButton]           = ImColor(255, 255, 255,   0);
            m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor(192, 192, 192, 192);
            m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor(192, 192, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(  0, 255,   0, 128);
            m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  0,   0, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(255,   0,   0, 128);
            m_StyleColors[BluePrintStyleColor_PinVoid]              = ImColor(255, 255, 255, 255);
            m_StyleColors[BluePrintStyleColor_PinAny]               = ImColor(255, 255, 255, 255);
            m_StyleColors[BluePrintStyleColor_PinFlow]              = ImColor(255, 255, 255, 255);
            m_StyleColors[BluePrintStyleColor_PinBool]              = ImColor( 48, 48,  220, 255);
            m_StyleColors[BluePrintStyleColor_PinInt32]             = ImColor( 68, 201, 156, 255);
            m_StyleColors[BluePrintStyleColor_PinInt64]             = ImColor(100,  34,  78, 255);
            m_StyleColors[BluePrintStyleColor_PinFloat]             = ImColor(147, 226,  74, 255);
            m_StyleColors[BluePrintStyleColor_PinDouble]            = ImColor( 72, 113,  37, 255);
            m_StyleColors[BluePrintStyleColor_PinString]            = ImColor(124,  21, 153, 255);
            m_StyleColors[BluePrintStyleColor_PinPoint]             = ImColor(220, 110,  10, 255);
            m_StyleColors[BluePrintStyleColor_PinVector]            = ImColor( 72, 110, 220, 255);
            m_StyleColors[BluePrintStyleColor_PinMat]               = ImColor(220,  64,  64, 255);
            m_StyleColors[BluePrintStyleColor_PinCustom]            = ImColor(208,  64,  64, 255);
            auto& editorStyle = ed::GetStyle();
            editorStyle.Colors[ed::StyleColor_Bg]           = ImColor( 60,  60,  70,  50);
            editorStyle.Colors[ed::StyleColor_NodeBg]       = ImColor( 32,  32,  32, 228);
            editorStyle.Colors[ed::StyleColor_NodeBorder]   = ImColor(255, 255, 255,  96);
            editorStyle.Colors[ed::StyleColor_SelNodeBorder]= ImColor(255, 176,  50, 255);
            editorStyle.Colors[ed::StyleColor_HovNodeBorder]= ImColor( 50, 176, 255, 255);
            editorStyle.Colors[ed::StyleColor_Flow]         = ImColor( 64, 128,  64, 255);
            editorStyle.Colors[ed::StyleColor_FlowDMarker]  = ImColor(255, 128,  10, 255);
            editorStyle.Colors[ed::StyleColor_FlowMarker]   = ImColor(128, 255, 128, 255);
        }
        break;
    case BluePrintStyle::BP_Style_Light:
        {
            ImGui::StyleColorsLight();
            if (m_Document) m_Document->m_Blueprint.SetStyleLight(true);
            ImGuiFileDialog::Instance()->SetDarkStyle();
            m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(128, 128, 255, 128);
            m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(128, 128, 255,  64);
            m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor( 96,  96, 255, 192);
            m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor( 96,  96, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(  0, 255,   0, 128);
            m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  0,   0, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(255,   0,   0, 128);
            m_StyleColors[BluePrintStyleColor_PinVoid]      = ImColor(   0,   0,   0, 255);
            m_StyleColors[BluePrintStyleColor_PinAny]       = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinFlow]      = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinBool]      = ImColor(  48, 48,  220, 255);
            m_StyleColors[BluePrintStyleColor_PinInt32]     = ImColor(  68, 201, 156, 255);
            m_StyleColors[BluePrintStyleColor_PinInt64]     = ImColor( 100,  34,  78, 255);
            m_StyleColors[BluePrintStyleColor_PinFloat]     = ImColor(  74, 113,  37, 255);
            m_StyleColors[BluePrintStyleColor_PinDouble]    = ImColor(  36,  56,  17, 255);
            m_StyleColors[BluePrintStyleColor_PinString]    = ImColor( 124,  21, 153, 255);
            m_StyleColors[BluePrintStyleColor_PinPoint]     = ImColor( 220, 110,  10, 255);
            m_StyleColors[BluePrintStyleColor_PinVector]    = ImColor(  72, 110, 220, 255);
            m_StyleColors[BluePrintStyleColor_PinMat]       = ImColor( 220,  10,  10, 255);
            m_StyleColors[BluePrintStyleColor_PinCustom]    = ImColor( 208,  64,  64, 255);
            auto& editorStyle = ed::GetStyle();
            editorStyle.Colors[ed::StyleColor_Bg]           = ImColor( 220, 220, 252,  72);
            editorStyle.Colors[ed::StyleColor_NodeBg]       = ImColor( 200, 200, 230, 228);
            editorStyle.Colors[ed::StyleColor_NodeBorder]   = ImColor( 128, 128, 255,  96);
            editorStyle.Colors[ed::StyleColor_SelNodeBorder]= ImColor(  20,  20, 255, 255);
            editorStyle.Colors[ed::StyleColor_HovNodeBorder]= ImColor(  50, 176, 255, 255);
            editorStyle.Colors[ed::StyleColor_Flow]         = ImColor(  64, 128,  64, 255);
            editorStyle.Colors[ed::StyleColor_FlowDMarker]  = ImColor( 255, 128,  10, 255);
            editorStyle.Colors[ed::StyleColor_FlowMarker]   = ImColor( 128, 255, 128, 255);
        }
        break;
    case BluePrintStyle::BP_Style_Mono:
        {
            ImGui::StyleColorsLight();
            ImGuiFileDialog::Instance()->SetLightStyle();
            if (m_Document) m_Document->m_Blueprint.SetStyleLight(true);
            m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(196, 196, 196, 196);
            m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(128, 128, 128,  64);
            m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor( 96,  96, 96, 192);
            m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor( 96,  96, 96, 128);
            m_StyleColors[BluePrintStyleColor_PinVoid]      = ImColor(   0,   0,   0, 255);
            m_StyleColors[BluePrintStyleColor_PinAny]       = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinFlow]      = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinBool]      = ImColor(  48,  48,   48, 255);
            m_StyleColors[BluePrintStyleColor_PinInt32]     = ImColor( 128, 128, 128, 255);
            m_StyleColors[BluePrintStyleColor_PinInt64]     = ImColor( 144, 144, 144, 255);
            m_StyleColors[BluePrintStyleColor_PinFloat]     = ImColor(  74,  74,  74, 255);
            m_StyleColors[BluePrintStyleColor_PinDouble]    = ImColor(  36,  36,  36, 255);
            m_StyleColors[BluePrintStyleColor_PinString]    = ImColor(  48,  48,  48, 255);
            m_StyleColors[BluePrintStyleColor_PinPoint]     = ImColor(  64,  64,  64, 255);
            m_StyleColors[BluePrintStyleColor_PinVector]    = ImColor(  32,  32,  32, 255);
            m_StyleColors[BluePrintStyleColor_PinMat]       = ImColor(110, 110, 110, 255);
            m_StyleColors[BluePrintStyleColor_PinCustom]    = ImColor(  20,  20,  20, 255);
            m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(   0,   0,   0, 128);
            m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  64,  64,  64, 128);
            m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(   0,   0,   0, 128);

            auto& editorStyle = ed::GetStyle();
            editorStyle.Colors[ed::StyleColor_Bg]           = ImColor( 220, 220, 220,  72);
            editorStyle.Colors[ed::StyleColor_NodeBg]       = ImColor( 200, 200, 200, 228);
            editorStyle.Colors[ed::StyleColor_NodeBorder]   = ImColor( 128, 128, 128,  96);
            editorStyle.Colors[ed::StyleColor_SelNodeBorder]= ImColor(  20,  20,  20, 255);
            editorStyle.Colors[ed::StyleColor_HovNodeBorder]= ImColor(  72,  72,  72, 255);
            editorStyle.Colors[ed::StyleColor_Flow]         = ImColor(  64,  64,  64, 255);
            editorStyle.Colors[ed::StyleColor_FlowDMarker]  = ImColor(  32,  32,  32, 255);
            editorStyle.Colors[ed::StyleColor_FlowMarker]   = ImColor(  10,  10,  10, 128);
        }
        break;
    default:
        break;
    }
    m_Style = style;
}

void BluePrintUI::SetCallbacks(BluePrintCallbackFunctions callbacks, void * handle)
{
    m_CallBacks = callbacks;
    m_UserHandle = handle;
}

void BluePrintUI::Resume()
{
    ReadyToQuit = false;
}

bool BluePrintUI::Frame(bool child_window, bool show_node, bool bp_enabled, uint32_t flag)
{
    bool done = false;
    if (!m_Editor || !m_Document || ReadyToQuit)
        return true;
    auto& io = ImGui::GetIO();
    bool multiviewport = io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable;
    const ImGuiViewport* viewport = ImGui::GetMainViewport();
    if (!child_window)
    {
        m_isChildWindow = false;
        if (m_DebugOverlay) m_DebugOverlay->Enable(true);
        ImVec2 Canvas_size;
        ImGuiWindowFlags flags = ImGuiWindowFlags_None;
        ImGuiCond cond = ImGuiCond_Once;
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            io.ConfigViewportsNoDecoration = false;
            flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove |
                        ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | 
                        ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoDocking;
            Canvas_size = viewport->WorkSize;
            ImGui::SetNextWindowPos(viewport->WorkPos);
            ImGui::SetNextWindowSize(viewport->WorkSize);
            ImGui::SetNextWindowViewport(viewport->ID);
        }
        else
        {
            flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove |
                            ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | 
                            ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoBringToFrontOnFocus;
            Canvas_size = io.DisplaySize;
            cond = ImGuiCond_None;
            ImGui::SetNextWindowPos(ImVec2(0, 0));
            ImGui::SetNextWindowSize(io.DisplaySize, cond);
        }
        
        ImGui::Begin("Content", nullptr, flags);
            ImVec2 debug_min = ImGui::GetItemRectMin();
            ImVec2 debug_max = Canvas_size;
            if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
            {
                debug_min = ImGui::GetWindowPos();
                debug_max = debug_min + ImGui::GetWindowSize();
            }
            ed::SetCurrentEditor(m_Editor);
            UpdateActions();
            ShowToolbar();
            ShowSettingPanel(&m_ShowSettingPanel);
            if (m_isShowThumbnails || m_ThumbnailShowCount > 0) Thumbnails(2.f);
            ed::Begin("###main_editor");
                if (show_node)
                    DrawNodes();
                else
                    CommitLinksToEditor();
                HandleCreateAction();
                HandleDestroyAction();
                HandleContextMenuAction();
                ShowDialogs();
                DrawInfoTooltip();
            ed::End();
            FileDialogs();
            ed::SetCurrentEditor(nullptr); // Don't Stop ed?

        ImGui::End();
        io.ConfigViewportsNoDecoration = true;
    }
    else
    {
        m_isChildWindow = true;
        if (m_DebugOverlay) m_DebugOverlay->Enable(false);
        ed::SetCurrentEditor(m_Editor);
        ed::EnableDragOverBorder(false);
        UpdateActions();
        ShowShortToolbar(flag & BluePrintFlag_Vertical);
        if (m_isShowThumbnails || m_ThumbnailShowCount > 0)
        {
            ImVec2 window_pos = ImGui::GetWindowPos();
            ImVec2 window_size = ImGui::GetWindowSize();
            Thumbnails(2.f, window_size, window_pos + window_size - window_size * m_ThumbnailScale);
        }
        ed::Begin("###main_editor");
        if (bp_enabled)
        {
            if (show_node)
                DrawNodes();
            else
                CommitLinksToEditor();
            HandleCreateAction(flag);
            HandleDestroyAction();
            HandleContextMenuAction(flag);
            ShowDialogs();
            DrawInfoTooltip(); // for debug
        }
        ed::End();
        FileDialogs();
        ed::SetCurrentEditor(nullptr);
    }

    EndOpRecord();
    return done;
}

void BluePrintUI::CreateNewDocument()
{
    auto blueprint = &m_Document->m_Blueprint;
    auto entryPointNode = blueprint->CreateNode<BluePrint::SystemEntryPointNode>();
                            ed::SetNodePosition(entryPointNode->m_ID, ImVec2(64, 64));

    auto exitPointNode = blueprint->CreateNode<BluePrint::SystemExitPointNode>();
                            ed::SetNodePosition(exitPointNode->m_ID, ImVec2(256, 256));
    entryPointNode->m_Exit.LinkTo(exitPointNode->m_Enter);
    CommitLinksToEditor();
    blueprint->SetOpen(true);
}

void BluePrintUI::CreateNewFilterDocument()
{
    ed::SetCurrentEditor(m_Editor);
    auto blueprint = &m_Document->m_Blueprint;
    auto entryPointNode = blueprint->CreateNode<BluePrint::FilterEntryPointNode>();
                            ed::SetNodePosition(entryPointNode->m_ID, ImVec2(32, 32));

    auto view_size = ed::GetViewSize();
    if (view_size.x == 0 || view_size.y == 0)
    {
        view_size = ImVec2(600, 300);
    }
    auto exitPointNode = blueprint->CreateNode<BluePrint::MatExitPointNode>();
                            ed::SetNodePosition(exitPointNode->m_ID, view_size - ImVec2(32 + 64, 32));
    entryPointNode->m_Exit.LinkTo(exitPointNode->m_Enter);
    exitPointNode->m_MatIn.LinkTo(entryPointNode->m_MatOut);
    CommitLinksToEditor();
    blueprint->SetOpen(true);
    //ed::SetCurrentEditor(nullptr);
}

void BluePrintUI::CreateNewTransitionDocument()
{
    ed::SetCurrentEditor(m_Editor);
    auto blueprint = &m_Document->m_Blueprint;
    auto entryPointNode = blueprint->CreateNode<BluePrint::TransitionEntryPointNode>();
                            ed::SetNodePosition(entryPointNode->m_ID, ImVec2(32, 32));

    auto view_size = ed::GetViewSize();
    if (view_size.x == 0 || view_size.y == 0)
        view_size = ImVec2(600, 200);

    auto exitPointNode = blueprint->CreateNode<BluePrint::MatExitPointNode>();
                            ed::SetNodePosition(exitPointNode->m_ID, view_size - ImVec2(32 + 64, 32));

    entryPointNode->m_Exit.LinkTo(exitPointNode->m_Enter);
    exitPointNode->m_MatIn.LinkTo(entryPointNode->m_MatOutFirst);
    CommitLinksToEditor();
    blueprint->SetOpen(true);
    //ed::SetCurrentEditor(nullptr);
}

void BluePrintUI::InstallDocumentCallbacks()
{
    m_Config.UserPointer = this;
    m_Config.BeginSaveSession = [](void* userPointer)
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            self->m_Document->OnSaveBegin();
    };
    m_Config.EndSaveSession = [](void* userPointer)
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            self->m_Document->OnSaveEnd();
    };
    m_Config.SaveSettingsJson = [](const imgui_json::value& state, ed::SaveReasonFlags reason, void* userPointer) -> bool
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnSaveState(state, reason);
        else
            return false;
    };
    m_Config.LoadSettingsJson = [](void* userPointer) -> imgui_json::value
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnLoadState();
        else
            return {};
    };
    m_Config.SaveNodeSettingsJson = [](ed::NodeId nodeId, const imgui_json::value& value, ed::SaveReasonFlags reason, void* userPointer) -> bool
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnSaveNodeState(static_cast<ID_TYPE>(nodeId.Get()), value, reason);
        else
            return false;
    };
    m_Config.LoadNodeSettingsJson = [](ed::NodeId nodeId, void* userPointer) -> imgui_json::value
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnLoadNodeState(static_cast<ID_TYPE>(nodeId.Get()));
        else
            return {};
    };

    struct TransactionWrapper final: ed::ITransaction
    {
        static const char* ActionToString(ed::TransactionAction action)
        {
            switch (action)
            {
                case ed::TransactionAction::Unknown:    return "Unknown";
                case ed::TransactionAction::Navigation: return "Navigation";
                case ed::TransactionAction::DragStart:  return "DragStart";
                case ed::TransactionAction::Dragging:   return "Dragging";
                case ed::TransactionAction::DragEnd:    return "DragEnd";
                case ed::TransactionAction::Resize:     return "Resize";
                default : return "";
            }
            return "";
        }
        TransactionWrapper(shared_ptr<BluePrint::Document::UndoTransaction> transaction)
            : m_Transaction(std::move(transaction))
        {
        }
        void AddAction(ed::TransactionAction action, const char* name) override
        {
            if (action == ed::TransactionAction::Navigation)
            {
                auto self = reinterpret_cast<BluePrintUI*>(m_Transaction->GetDocument()->m_UserData);
                if (self) self->m_ThumbnailShowCount = THUMBNAIL_COUNT;
            }
        }
        void Commit() override
        {
            ImGuiTextBuffer name;
            if (m_ActionCount == m_DragActionCount && m_DragActionCount > 1)
                name.appendf("Drag %d nodes", static_cast<int>(m_DragActionCount));
            m_Transaction->Commit(name.c_str());
        }
        void Discard() override
        {
            m_Transaction->Discard();
        }
        void AddAction(ed::TransactionAction action, ed::NodeId nodeId, const char* name) override
        {
            auto& blueprint = m_Transaction->GetDocument()->GetBlueprint();
            auto  node = const_cast<BP&>(blueprint).FindNode(static_cast<ID_TYPE>(nodeId.Get()));
            if (!node)
                return;
            auto self = reinterpret_cast<BluePrintUI*>(m_Transaction->GetDocument()->m_UserData);
            ++m_ActionCount;
            m_NodeIds.push_back(nodeId);
            if (action == ed::TransactionAction::DragStart)
            {
                ++m_DragActionCount;
                node->OnDragStart(blueprint.GetContext());
                m_Transaction->AddAction("Drag Start %" PRI_node, FMT_node(node));
                if (self) self->m_ThumbnailShowCount = THUMBNAIL_COUNT;
            }
            else if (action == ed::TransactionAction::Dragging)
            {
                ++m_DragActionCount;
                node->OnDragging(blueprint.GetContext());
                m_Transaction->AddAction("Dragging %" PRI_node, FMT_node(node));
                if (self) self->m_ThumbnailShowCount = THUMBNAIL_COUNT;
            }
            else if (action == ed::TransactionAction::DragEnd)
            {
                ++m_DragActionCount;
                node->OnDragEnd(blueprint.GetContext());
                m_Transaction->AddAction("Drag End %" PRI_node, FMT_node(node));
            }
            else if (action == ed::TransactionAction::Resize)
            {
                node->OnResize(blueprint.GetContext());
                m_Transaction->AddAction("Resize %" PRI_node, FMT_node(node));
                if (self) self->m_ThumbnailShowCount = THUMBNAIL_COUNT;
            }
            else if (action == ed::TransactionAction::Select)
            {
                node->OnSelect(blueprint.GetContext());
                m_Transaction->AddAction("Select %" PRI_node, FMT_node(node));
            }
            else if (action == ed::TransactionAction::Deselect)
            {
                node->OnDeselect(blueprint.GetContext());
                m_Transaction->AddAction("Deselect %" PRI_node, FMT_node(node));
            }
            else
                m_Transaction->AddAction("%s", name);
        }
        void AddAction(ed::TransactionAction action, ed::LinkId linkId, const char* name) override
        {
            auto& blueprint = m_Transaction->GetDocument()->GetBlueprint();
            auto  link = const_cast<BP&>(blueprint).FindPin(static_cast<ID_TYPE>(linkId.Get()));
            if (!link)
                return;
            ++m_ActionCount;
            m_Transaction->AddAction("%s Link %" PRIX32, name, link->m_ID);
        }
        shared_ptr<BluePrint::Document::UndoTransaction> m_Transaction;
        size_t m_ActionCount = 0;
        size_t m_DragActionCount = 0;
        vector<ed::NodeId> m_NodeIds;
    };
    m_Config.TransactionInterface.Constructor = [](const char* name, void* userPointer) -> ed::ITransaction*
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (!self || !self->m_Document) return nullptr;
        return new TransactionWrapper(self->m_Document->BeginUndoTransaction(name));
    };
    m_Config.TransactionInterface.Destructor = [](ed::ITransaction* transaction, void* userPointer)
    {
        delete transaction;
    };
    m_Config.TransactionInterface.UserPointer = this;
}

float BluePrintUI::DrawNodeToolBar(Node *node, Node **need_clone_node)
{
    if (!m_Document)
        return 0.f;
    auto current_pos = ImGui::GetCursorScreenPos();
    bool isThreadExecuting = m_Document->m_Blueprint.IsExecuting();
    ImGui::PushStyleColor(ImGuiCol_Button, m_StyleColors[BluePrintStyleColor_ToolButton]);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_StyleColors[BluePrintStyleColor_ToolButtonHovered]);
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, m_StyleColors[BluePrintStyleColor_ToolButtonActive]);
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));
    ImGui::PushStyleVar(ImGuiStyleVar_ItemInnerSpacing, ImVec2(0,0));
    ImGui::PushStyleColor(ImGuiCol_TexGlyphShadow, ImVec4(0.1, 0.1, 0.1, 0.8));
    ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));

    auto node_size = ed::GetNodeSize(node->m_ID);
    float icon_offset = 16 + 2; // base offset + resize speed
    const float icon_gap = 18;
    if (node->m_Skippable)
    {
        icon_offset += icon_gap;
        ImGui::SetCursorScreenPos(current_pos + ImVec2(node_size.x - icon_offset, 8));
        if (ImGui::Button((std::string((node->m_Enabled ? ICON_NODE_ENABLE : ICON_NODE_DISABLE)) + "##" + std::to_string(node->m_ID)).c_str())) 
        {
            node->m_Enabled = !node->m_Enabled;
            if (node->m_Enabled) LOGI("[HandleNodeToolBar] Enable for %" PRI_node, FMT_node(node));
            else                 LOGI("[HandleNodeToolBar] Disable for %" PRI_node, FMT_node(node));
            ed::SetNodeChanged(node->m_ID);
            if (m_CallBacks.BluePrintOnChanged)
            {
                m_CallBacks.BluePrintOnChanged(BP_CB_PARAM_CHANGED, m_Document->m_Name, m_UserHandle);
            }
        }
        if (ImGui::IsItemHovered()) node->m_IconHovered = 4;
    }
    ImGui::BeginDisabled(isThreadExecuting);
    if (node->GetStyle() == NodeStyle::Group)
    {
        icon_offset += icon_gap;
        ImGui::SetCursorScreenPos(current_pos + ImVec2(node_size.x - icon_offset, 8));
        if (ImGui::Button((titlebar_icons[3] + "##" + std::to_string(node->m_ID)).c_str())) 
        {
            ed::Suspend();
            LOGI("[HandleNodeToolBar] Open NodeSavingDialog for %" PRI_node, FMT_node(node));
            File_Export(node);
            ed::Resume();
        }
        if (ImGui::IsItemHovered()) node->m_IconHovered = 3;
    }
    if ((!m_ShowSettingPanel || node->GetStyle() == NodeStyle::Group || node->GetStyle() == NodeStyle::Comment) && node->m_HasSetting)
    {
        icon_offset += icon_gap;
        ImGui::SetCursorScreenPos(current_pos + ImVec2(node_size.x - icon_offset, 8));
        if (ImGui::Button((titlebar_icons[2] + "##" + std::to_string(node->m_ID)).c_str())) 
        {
            ed::Suspend();
            LOGI("[HandleNodeToolBar] Open NodeSettingDialog for %" PRI_node, FMT_node(node));
            m_NodeSettingDialog.Open(node);
            ed::Resume();
        }
        if (ImGui::IsItemHovered()) node->m_IconHovered = 2;
    }

    icon_offset += icon_gap;
    ImGui::SetCursorScreenPos(current_pos + ImVec2(node_size.x - icon_offset, 8));
    if (ImGui::Button((titlebar_icons[1] + "##" + std::to_string(node->m_ID)).c_str())) 
    {
        ed::Suspend();
        LOGI("[HandleNodeToolBar] Open NodeDeleteDialog for %" PRI_node, FMT_node(node));
        m_NodeDeleteDialog.Open(node);
        ed::Resume();
    }
    if (ImGui::IsItemHovered()) node->m_IconHovered = 1;

    icon_offset += icon_gap;
    ImGui::SetCursorScreenPos(current_pos + ImVec2(node_size.x - icon_offset, 8));
    if (ImGui::Button((titlebar_icons[0] + "##" + std::to_string(node->m_ID)).c_str())) 
    {
        *need_clone_node = node;
    }
    if (ImGui::IsItemHovered()) node->m_IconHovered = 0;

    ImGui::EndDisabled();
    ImGui::PopStyleVar(3);
    ImGui::PopStyleColor(4);
    return icon_offset;
}

bool BluePrintUI::CheckNodeStyle(const Node* node, NodeStyle style)
{
    bool checked = false;
    DummyNode * dummy = nullptr;
    auto isDummy = node->GetStyle() == NodeStyle::Dummy;
    if (isDummy)
        dummy = (DummyNode *)node;
    checked = node->GetStyle() == style || (dummy ? dummy->m_style == style : false);
    return checked;
}

void BluePrintUI::CommitLinksToEditor()
{
    auto pins = m_Document->m_Blueprint.GetPins();
    for (auto pin : pins)
    {
        if (!pin->m_Link)
        {
            if (!(pin->m_Flags & PIN_FLAG_LINKED)) pin->m_LinkFrom.clear();
            continue;
        }

        auto link = pin->GetLink(&m_Document->m_Blueprint);
        if (!link)
        {
            pin->m_Link = 0;
            continue;
        }

        if (std::find(pins.begin(), pins.end(), link) == pins.end())
        {
            pin->m_Link = 0;
            continue;
        }
        
        // To keep things simple, link id is same as pin id.
        // check link is between bridge and shadow
        //bool inner_link = pin->IsMappedPin() && link->IsMappedPin() && pin->m_MappedPin && pin->m_MappedPin == link->m_MappedPin;
        //ed::Link(pin->m_ID, pin->m_ID, pin->m_Link, (inner_link ? ImVec4(0, 0, 0,  0) : PinTypeToColor(this, pin->GetValueType())), 1.5); // Maybe add to setting
        ed::Link(pin->m_ID, pin->m_ID, pin->m_Link, PinTypeToColor(this, pin->GetValueType()), 3.0); // Maybe add to setting
        pin->m_Flags |= PIN_FLAG_LINKED;
        link->m_Flags |= PIN_FLAG_LINKED;
        if (std::find(link->m_LinkFrom.begin(), link->m_LinkFrom.end(), pin->m_ID) == link->m_LinkFrom.end())
        {
            link->m_LinkFrom.push_back(pin->m_ID);
        }
    }
}

ImVec2 BluePrintUI::Blueprint_EstimateNodeSize(Node* node)
{
    ImVec2 node_size = ed::GetNodeSize(node->m_ID);
    if (CheckNodeStyle(node, NodeStyle::Group))
        return node_size;
    if (node_size.x <= 0 || node_size.y <= 0)
    {
        node_size = ImVec2(0, 0);
        const auto iconSize = ImVec2(ImGui::GetTextLineHeight(), ImGui::GetTextLineHeight());
        auto isDummy = node->GetStyle() == NodeStyle::Dummy;
        auto isSimple = node->GetStyle() == NodeStyle::Simple;
        auto nodeName = !isDummy ? node->GetName() : ((DummyNode *)node)->m_name + "*load fail*";
        if (!nodeName.empty())
        {
            const float titleTextWidth = ImGui::CalcTextSize(nodeName.c_str()).x;
            const float titleTextHeight = ImGui::CalcTextSize(nodeName.c_str()).y;
            node_size.x += titleTextWidth;
            if (!isDummy && !isSimple) node_size.x += 18 * 6;
            if (!isSimple) node_size.y += titleTextHeight;
        }

        int max_pin_width = 0;
        for (auto& pin : node->GetInputPins())
        {
            if (!pin->m_Name.empty() && (!CheckNodeStyle(node, NodeStyle::Simple) || pin->m_Flags & PIN_FLAG_FORCESHOW) && (!node->m_HasCustomLayout || m_isChildWindow)) 
            {
                const float pinwidth = ImGui::CalcTextSize(pin->m_Name.c_str()).x;
                if (max_pin_width < pinwidth) max_pin_width = pinwidth;
            }
        }
        node_size.x += max_pin_width;
        max_pin_width = 0;
        for (auto& pin : node->GetOutputPins())
        {
            if (!pin->m_Name.empty() && (!CheckNodeStyle(node, NodeStyle::Simple) || pin->m_Flags & PIN_FLAG_FORCESHOW) && (!node->m_HasCustomLayout || m_isChildWindow)) 
            {
                const float pinwidth = ImGui::CalcTextSize(pin->m_Name.c_str()).x;
                if (max_pin_width < pinwidth) max_pin_width = pinwidth;
            }
        }
        node_size.x += max_pin_width;
        if (node->m_HasCustomLayout && !m_isChildWindow)
        {
            // hard to estimate
            node_size.x += 200;
            node_size.y += 200;
        }
        else if (m_isChildWindow)
        {
            node_size.x += 200;
        }
        int pins = ImMax(node->GetInputPins().size(),node->GetOutputPins().size());
        node_size.y = ImMax(node_size.y, (float)(pins * (16 + 4) + 4));
    }

    return node_size;
}

void BluePrintUI::DrawNodes()
{
    if (!m_Document)
        return;
    const auto iconSize = ImVec2(ImGui::GetTextLineHeight(), ImGui::GetTextLineHeight());
    if (m_DebugOverlay) m_DebugOverlay->Begin();
    Node* need_clone_node = nullptr;
    auto show_pin_name = [](std::string name)
    {
        auto pos = name.find_first_of("##");
        if (pos == std::string::npos)
            ImGui::TextUnformatted(name.data(), name.data() + name.size());
        else
        {
            auto sub_label = name.substr(0, pos);
            ImGui::TextUnformatted(sub_label.data(), sub_label.data() + sub_label.size());
        }
    };
    // Commit all nodes to editor
    // Handling Comment/Group Node
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        auto isDummy = node->GetStyle() == NodeStyle::Dummy;
        auto isGroup = CheckNodeStyle(node, NodeStyle::Group);
        auto isGrouped = node->m_GroupID != 0;
        if (!CheckNodeStyle(node, NodeStyle::Comment) && !CheckNodeStyle(node, NodeStyle::Group))
            continue;
        const float commentAlpha = 0.75f;
        node->m_IconHovered = -1;
        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, commentAlpha);
        //ed::PushStyleColor(ed::StyleColor_NodeBg, m_StyleColors[BluePrintStyleColor_GroupBg]);
        if (isDummy)
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder, m_StyleColors[BluePrintStyleColor_DummyBorder]);
        }
        else
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder, m_StyleColors[BluePrintStyleColor_Border]);
        }
        ed::BeginNode(node->m_ID);
        // Comment/Group node layout:
        //
        // [ Comment ]                         |     [ Group ]                              |
        // +-----------------------------------+     +--------------------------------------+
        // | Title                  iC iD iS   |     | Title                    is iC iD iS |
        // | +-----------[ Dummy ]-----------+ |     | +-----------[ Dummy ]--------------+ |
        // |                                   |     || i Pin |                    | Pin o ||
        // |                                   |     || i Pin |                    | Pin o ||
        // |            [ Content ]            |     |    .        [ Content ]         .    |
        // |                                   |     |    .                            .    |
        // |                                   |     || i Pin |                    | Pin o ||
        // +-----------------------------------+     +--------------------------------------+
        // PS: iS = Setting Icon, iC = Clone Icon, iD = Delete Icon, is = Save Icon
        ImGui::BeginVertical("content");
        // Show title if node has one.
        auto nodeName = !isDummy ? node->GetName() : ((DummyNode *)node)->m_name + "*load fail*";
        float title_height = 0;
        float title_width = 0;
        if (!nodeName.empty())
        {
            const float titleTextWidth = ImGui::CalcTextSize(nodeName.c_str()).x;
            const float titleTextHeight = ImGui::CalcTextSize(nodeName.c_str()).y;
            const float textSizeButton = ImGui::CalcTextSize(titlebar_icons[0].c_str()).x;
            const float dummyWidth = titleTextWidth + textSizeButton * 5 + 10;
            ImGui::Dummy(ImVec2(dummyWidth, 0));
            ImGui::BeginHorizontal("horizontal");
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::GetWindowDrawList()->AddTextComplex(nodeName.c_str(), 1.f, IM_COL32_WHITE, 1.0f, IM_COL32(128, 128, 128, 255), ImVec2(2.0, 2.0), IM_COL32(32, 32, 32, 255));
            ImGui::Dummy(ImVec2(0, ImGui::GetFontSize()));
            if (font) ImGui::PopFont();
            ImGui::EndHorizontal();
            ImGui::Dummy(ImVec2(dummyWidth, 8));
            title_height = titleTextHeight + 10;
            title_width = dummyWidth;
        }
        ImGui::EndVertical();
        auto nodeStart = ed::GetNodePosition(node->m_ID);
        ImGui::SetCursorScreenPos(nodeStart);
        if (!isDummy) title_width += DrawNodeToolBar(node, &need_clone_node);
        auto inPinPosMin = ed::GetNodePosition(node->m_ID); inPinPosMin.x += 8; inPinPosMin.y += title_height + 16;
        auto groupSize  = ed::GetGroupSize(node->m_ID);
        if (groupSize.x == 0)
            groupSize.x = title_width;
        ed::Group(groupSize);
        auto outPinPosMin = ed::GetNodePosition(node->m_ID); outPinPosMin.x += groupSize.x - 16; outPinPosMin.y += title_height + 16;

        if (isGroup)
        {
            node->Update();
            auto drawList = ImGui::GetWindowDrawList();
            auto num_inpin = node->GetInputPins().size();
            if (num_inpin > 0)
            {
                // Input pin layout:
                //
                //     +-[1]---+
                //     |       |
                //    [X] Icon |
                //     |       |
                //     +-------+
                auto inPinPosMax = inPinPosMin + ImVec2(24, num_inpin * (iconSize.y + 4) + 4);
                drawList->AddRectFilled(
                    inPinPosMin,
                    inPinPosMax,
                    ImGui::GetColorU32(m_StyleColors[BluePrintStyleColor_GroupBg]), 8.0f);
                auto PinMin = inPinPosMin + ImVec2(4, 4);
                for (auto& pin : node->GetInputPins())
                {
                    auto PinMax = PinMin + iconSize;
                    // draw shadow pin
                    if (pin->m_Type == PinType::Flow)
                    {
                        auto spin = pin->GetLink(&m_Document->m_Blueprint);
                        if (spin)
                        {
                            ed::BeginPin(spin->m_ID, ed::PinKind::Output);
                            ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
                            ed::PinRect(PinMin, PinMax);
                            DrawIcon(drawList, PinMin, PinMax,
                                    PinTypeToIconType(spin->GetType()),
                                    false,
                                    ImColor(ImVec4(0, 0, 0, 0)),
                                    ImColor(ImVec4(0, 0, 0, 0)));
                            ed::EndPin();
                        }
                    }
                    else
                    {
                        if (pin->m_LinkFrom.size() == 1)
                        {
                            auto spin = m_Document->m_Blueprint.GetPinFromID(pin->m_LinkFrom[0]);
                            if (spin)
                            {
                                ed::BeginPin(spin->m_ID, ed::PinKind::Output);
                                ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
                                ed::PinRect(PinMin, PinMax);
                                DrawIcon(drawList, PinMin, PinMax,
                                        PinTypeToIconType(spin->GetType()),
                                        false,
                                        ImColor(ImVec4(0, 0, 0, 0)),
                                        ImColor(ImVec4(0, 0, 0, 0)));
                                ed::EndPin();
                            }
                        }
                    }
                    // draw bridge pin
                    bool link_outside = false;
                    if (pin->m_Type == PinType::Flow)
                        link_outside = pin->m_LinkFrom.size() > 0;
                    else
                        link_outside = pin->m_Link != 0;
                    ed::BeginPin(pin->m_ID, ed::PinKind::Input);
                    ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
                    ed::PinRect(PinMin, PinMax);
                    DrawIcon(drawList, PinMin, PinMax,
                            PinTypeToIconType(pin->GetType()),
                            link_outside,
                            ImColor(PinTypeToColor(this, pin->GetValueType())),
                            ImColor(ImVec4(0, 0, 0, 0)));
                    ed::EndPin();

                    //if (m_DebugOverlay) m_DebugOverlay->DrawInputPin(this, *pin);
                    PinMin += ImVec2(0, iconSize.y + 4);
                    //ImGui::Debug_DrawItemRect();
                }
            }
            // Output pin layout:
            //
            //    +-[1]---+
            //    |       |
            //    | Icon [X]
            //    |       |
            //    +-------+
            auto num_outpin = node->GetOutputPins().size();
            if (num_outpin > 0)
            {
                auto outPinPosMax = outPinPosMin + ImVec2(24, num_outpin * (16 + 4) + 4);
                drawList->AddRectFilled(
                    outPinPosMin,
                    outPinPosMax,
                    ImGui::GetColorU32(m_StyleColors[BluePrintStyleColor_GroupBg]), 8.0f);
                auto PinMin = outPinPosMin + ImVec2(4, 4);
                for (auto& pin : node->GetOutputPins())
                {
                    auto PinMax = PinMin + iconSize;
                    // draw shadow pin
                    if (pin->m_Type == PinType::Flow)
                    {
                        if (pin->m_LinkFrom.size() == 1)
                        {
                            auto spin = m_Document->m_Blueprint.GetPinFromID(pin->m_LinkFrom[0]);
                            if (spin)
                            {
                                ed::BeginPin(spin->m_ID, ed::PinKind::Input);
                                ed::PinPivotAlignment(ImVec2(0.0f, 0.5f));
                                ed::PinRect(PinMin, PinMax);
                                DrawIcon(drawList, PinMin, PinMax,
                                        PinTypeToIconType(spin->GetType()),
                                        false,
                                        ImColor(ImVec4(0, 0, 0, 0)),
                                        ImColor(ImVec4(0, 0, 0, 0)));
                                ed::EndPin();
                            }
                        }
                    }
                    else
                    {
                        auto spin = pin->GetLink(&m_Document->m_Blueprint);
                        if (spin)
                        {
                            ed::BeginPin(spin->m_ID, ed::PinKind::Input);
                            ed::PinPivotAlignment(ImVec2(0.0f, 0.5f));
                            ed::PinRect(PinMin, PinMax);
                            DrawIcon(drawList, PinMin, PinMax,
                                    PinTypeToIconType(spin->GetType()),
                                    false,
                                    ImColor(ImVec4(0, 0, 0, 0)),
                                    ImColor(ImVec4(0, 0, 0, 0)));
                            ed::EndPin();
                        }
                    }
                    // draw bridge pin
                    bool link_outside = false;
                    if (pin->m_Type == PinType::Flow)
                        link_outside = pin->m_Link != 0;
                    else
                        link_outside = pin->m_LinkFrom.size() > 0;
                    ed::BeginPin(pin->m_ID, ed::PinKind::Output);
                    ed::PinPivotAlignment(ImVec2(0.2f, 0.5f));
                    ed::PinRect(PinMin, PinMax);
                    DrawIcon(drawList, PinMin, PinMax,
                            PinTypeToIconType(pin->GetType()),
                            link_outside,
                            ImColor(PinTypeToColor(this, pin->GetValueType())),
                            ImColor(ImVec4(0, 0, 0, 0)));
                    ed::EndPin();
                    //if (m_DebugOverlay) m_DebugOverlay->DrawOutputPin(this, *pin);
                    PinMin += ImVec2(0, iconSize.y + 4);
                    //ImGui::Debug_DrawItemRect();
                }
            }
        }
        ed::EndNode();
#if DEBUG_NODE_DRAWING
        ImGui::Debug_DrawItemRect();
#endif
        ed::PopStyleColor();
        ImGui::PopStyleVar();

        // Draw Title zoom out
        if (ed::BeginGroupHint(node->m_ID))
        {
            auto bgAlpha = static_cast<int>(ImGui::GetStyle().Alpha * 255);
            auto min = ed::GetGroupMin();
            ImGui::SetCursorScreenPos(min - ImVec2(-8, ImGui::GetTextLineHeightWithSpacing() + 4));
            ImGui::BeginGroup();
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::TextUnformatted(nodeName.data());
            if (font) ImGui::PopFont();
            ImGui::EndGroup();
            auto drawList = ed::GetHintBackgroundDrawList();
            auto hintBounds      = ed::Detail::ImGui_GetItemRect();
            auto hintFrameBounds = ed::Detail::ImRect_Expanded(hintBounds, 8, 4);
            drawList->AddRectFilled(
                hintFrameBounds.GetTL(),
                hintFrameBounds.GetBR(),
                IM_COL32(255, isDummy ? 0 : 255, isDummy ? 0 : 255, 64 * bgAlpha / 255), 4.0f);
            drawList->AddRect(
                hintFrameBounds.GetTL(),
                hintFrameBounds.GetBR(),
                IM_COL32(255, isDummy ? 0 : 255, isDummy ? 0 : 255, 128 * bgAlpha / 255), 4.0f);
        }
        ed::EndGroupHint();

        if (m_DebugOverlay) m_DebugOverlay->DrawNode(this, *node);
    }

    // Handling Default and SimpleNode
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        auto isDummy = node->GetStyle() == NodeStyle::Dummy;
        auto isGrouped = node->m_GroupID != 0;
        if (!CheckNodeStyle(node, NodeStyle::Default) && !CheckNodeStyle(node, NodeStyle::Simple))
            continue;
        node->m_IconHovered = -1;
        if (isDummy)
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder,    ImColor(255, 32,  32, 200));
        }
#if DEBUG_GROUP_NODE
        else if (isGrouped)
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder,    ImColor(32, 255,  32, 200));
        }
#endif
        if (node->m_NoBackGround)
            ed::PushStyleColor(ed::StyleColor_NodeBg, ImVec4(0.f, 0.f, 0.f, 0.f));
        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 1.f - node->m_Transparency);
        ed::BeginNode(node->m_ID);
        // Default node layout:                         Simple node layout:
        //
        // +-----------------------------------+         +-----------------------------------+
        // | Title               iC  iD  iS    |         | | i Pin |               | Pin o | |
        // | +-----------[ Dummy ]-----------+ |         | | i Pin |               | Pin o | |
        // | +---------------+   +-----------+ |         | |   .   |               | Pin o | |
        // | | i Pin         |   |   Out B o | |         | |   .   |    Title      |   .   | |
        // | | i Pin <Value> |   |   Out A o | |         | |   .   |               |   .   | |
        // | | i Pin         |   |           | |         | | i Pin |               |   .   | |
        // | +---------------+   +-----------+ |         | | i Pin |               | Pin o | |
        // +-----------------------------------+         +-----------------------------------+
        // PS: iS = Setting Icon, iC = Clone Icon, iD= Delete Icon
        // Show title if node has one.
        float dummy_width = 40;
        auto nodeName = !isDummy ? node->GetName() : 
                        !CheckNodeStyle(node, NodeStyle::Simple) ? ((DummyNode *)node)->m_name + "*load fail*" : "*err*";
        if (!nodeName.empty() && !CheckNodeStyle(node, NodeStyle::Simple))
        {
            auto headerBackgroundRenderer = ImGui::ItemBackgroundRenderer([node, this](ImDrawList* drawList)
            {
                auto isDummy = node->GetStyle() == NodeStyle::Dummy;
                auto border   = ed::GetStyle().NodeBorderWidth;
                auto rounding = ed::GetStyle().NodeRounding;
                auto nodeStart = ed::GetNodePosition(node->m_ID);
                auto nodeSize  = ed::GetNodeSize(node->m_ID);
                ImRect itemRect(ImGui::GetItemRectMin(), ImGui::GetItemRectMax());
                itemRect.Min = nodeStart;
                itemRect.Min.x = itemRect.Min.x + border - 0.5f;
                itemRect.Min.y = itemRect.Min.y + border - 0.5f;
                itemRect.Max.x = nodeStart.x + nodeSize.x - border + 0.5f;
                itemRect.Max.y = itemRect.Max.y + ImGui::GetStyle().ItemSpacing.y + 0.5f;
                drawList->AddRectFilled(itemRect.Min, itemRect.Max, ImColor(isDummy ? m_StyleColors[BluePrintStyleColor_TitleBgDummy] : m_StyleColors[BluePrintStyleColor_TitleBg]), rounding, ImDrawFlags_RoundCornersTop & (ImDrawFlags_RoundCornersLeft | ImDrawFlags_RoundCornersRight));
                auto size = ImVec2(8.0f, 8.0f);
                auto pos = itemRect.Min + ImVec2(6, (itemRect.Max.y - itemRect.Min.y) / 2 - size.y / 2);
                if (ImGui::BulletToggleButton("##set_break_point", &node->m_BreakPoint, pos, size))
                {
                    ed::SetNodeChanged(node->m_ID);
                }
                
                //ImGui::Debug_DrawItemRect();
            });
            ImGui::Dummy(ImVec2(0.1f, 0.f)); ImGui::SameLine(0);
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::GetWindowDrawList()->AddTextComplex(nodeName.c_str(), 1.f, IM_COL32_WHITE, 1.0f, IM_COL32(128, 128, 128, 255), ImVec2(2.0, 2.0), IM_COL32(16, 16, 16, 255));
            ImGui::Dummy(ImVec2(0, ImGui::GetFontSize()));
            if (font) ImGui::PopFont();
            const float titleTextSize = ImGui::CalcTextSize(nodeName.c_str()).x;
            if (!isDummy)
            {
                dummy_width = titleTextSize + 18 * 6;
            }
            else
            {
                dummy_width = titleTextSize;
            }
        }

        ImGui::Dummy(ImVec2(dummy_width, 0.0f)); // For minimum node width

        ImGui::Grid layout;
        layout.Begin(node->m_ID, CheckNodeStyle(node, NodeStyle::Simple) || (!m_isChildWindow && node->m_HasCustomLayout) ? 3 : 2, dummy_width + 36);
        layout.SetColumnAlignment(0.0f);
        // Draw column with input pins.
        for (auto& pin : node->GetInputPins())
        {
            // Add a bit of spacing to separate pins and make value not cramped
            ImGui::Spacing();
            // Input pin layout:
            //
            //     +-[1]---+-[2]------+-[3]----------+
            //     |       |          |              |
            //    [X] Icon | Pin Name | Value/Editor |
            //     |       |          |              |
            //     +-------+----------+--------------+
            ed::BeginPin(pin->m_ID, ed::PinKind::Input);
            // [X] - Tell editor to put pivot point in the middle of
            //       the left side of the pin. This is the point
            //       where link will be hooked to.
            //
            //       By default pivot is in pin center point which
            //       does not look good for blueprint nodes.
            ed::PinPivotAlignment(ImVec2(0.0f, 0.5f));
            // [1] - Icon
            Icon(iconSize,
                PinTypeToIconType(pin->GetType()),
                m_Document->m_Blueprint.HasPinAnyLink(*pin),
                pin->m_Flags & PIN_FLAG_EXPORTED,
                pin->m_Flags & PIN_FLAG_PUBLICIZED,
                PinTypeToColor(this, pin->GetValueType()));

            // [2] - Show pin name if it has one. Custom layout hidden name?
            if (!pin->m_Name.empty() && (!CheckNodeStyle(node, NodeStyle::Simple) || pin->m_Flags & PIN_FLAG_FORCESHOW) && (!node->m_HasCustomLayout || m_isChildWindow)) 
            {
                ImGui::SameLine();
                show_pin_name(pin->m_Name);
            }
            // [3] - Show value/editor when pin is not linked to anything
            if (!m_Document->m_Blueprint.HasPinAnyLink(*pin) && !CheckNodeStyle(node, NodeStyle::Simple) && !(node->m_HasCustomLayout || m_isChildWindow))
            {
                ImGui::SameLine();
                DrawPinValueWithEditor(*pin);
            }
            
            ed::EndPin();
            // [Debug Overlay] Show value of the pin if node is currently executed
            //if (m_DebugOverlay) m_DebugOverlay->DrawInputPin(this, *pin);
            layout.NextRow();
        }

        if (CheckNodeStyle(node, NodeStyle::Simple))
        {
            auto nodeSize  = ed::GetNodeSize(node->m_ID);
            float font_size = ImGui::GetFontSize();
            layout.SetColumnAlignment(1.0f);
            layout.NextColumn();
            if (node->GetInputPins().size() > 1 || node->GetOutputPins().size() > 1)
                ImGui::Dummy(ImVec2(0, (nodeSize.y - font_size * 2) / 4));
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::TextUnformatted(nodeName.data());
            if (font) ImGui::PopFont();
        }
        else if (node->m_HasCustomLayout && !m_isChildWindow)
        {
            layout.SetColumnAlignment(0.0f);
            layout.NextColumn();
            float zoom = ed::GetCurrentZoom();
            ImVec2 origin = ed::GetCurrentOrigin();
            if (node->DrawCustomLayout(ImGui::GetCurrentContext(), zoom, origin))
            {
                ed::SetNodeChanged(node->m_ID);
                if (m_CallBacks.BluePrintOnChanged)
                {
                    auto callback_ret = m_CallBacks.BluePrintOnChanged(BP_CB_PARAM_CHANGED, m_Document->m_Name, m_UserHandle);
                    if (callback_ret == BP_CBR_RunAgain)
                    {
                        m_Document->m_Blueprint.StepToEnd(node);
                    }
                }
            }
        }
        else if (m_isChildWindow)
        {
            layout.SetColumnAlignment(0.f);
            layout.NextColumn();
            auto nodeSize  = ed::GetNodeSize(node->m_ID);
            ImGui::Dummy(ImVec2(0, (nodeSize.y - 64 - 32) / 2));
            node->DrawNodeLogo(ImGui::GetCurrentContext(), ImVec2(112, 64), std::string(ICON_NODE));
        }
        else
            layout.SetColumnAlignment(1.0f);
        layout.NextColumn(false);
        // Draw column with output pins.
        for (auto& pin : node->GetOutputPins())
        {
            // Add a bit of spacing to separate pins and make value not cramped
            ImGui::Spacing();
            // Output pin layout:
            //
            //    +-[1]------+-[2]---+
            //    |          |       |
            //    | Pin Name | Icon [X]
            //    |          |       |
            //    +----------+-------+
            ed::BeginPin(pin->m_ID, ed::PinKind::Output);
            // [X] - Tell editor to put pivot point in the middle of
            //       the right side of the pin. This is the point
            //       where link will be hooked to.
            //
            //       By default pivot is in pin center point which
            //       does not look good for blueprint nodes.
            ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
            // [1] - Show pin name if it has one. Custom layout hidden name?
            if (!pin->m_Name.empty() && (!CheckNodeStyle(node, NodeStyle::Simple) || pin->m_Flags & PIN_FLAG_FORCESHOW) && (!node->m_HasCustomLayout || m_isChildWindow))
            {
                show_pin_name(pin->m_Name);
                ImGui::SameLine();
            }
            // [2] - Show icon
            Icon(iconSize,
                PinTypeToIconType(pin->GetType()),
                m_Document->m_Blueprint.HasPinAnyLink(*pin),
                pin->m_Flags & PIN_FLAG_EXPORTED,
                pin->m_Flags & PIN_FLAG_PUBLICIZED,
                PinTypeToColor(this, pin->GetValueType()));
            ed::EndPin();
            // [Debug Overlay] Show value of the pin if node is currently executed
            //if (m_DebugOverlay) m_DebugOverlay->DrawOutputPin(this, *pin);
            layout.NextRow();
        }
        layout.End();
        if (!isDummy && !CheckNodeStyle(node, NodeStyle::Simple))
        {
            auto nodeStart = ed::GetNodePosition(node->m_ID);
            ImGui::SetCursorScreenPos(nodeStart);
            DrawNodeToolBar(node, &need_clone_node);
        }

#if DEBUG_NODE_DRAWING
        ImGui::Debug_DrawItemRect();
#endif
        ImGui::PopStyleVar();
        if (node->m_NoBackGround)
            ed::PopStyleColor();
        ed::EndNode();
        if (isDummy)
            ed::PopStyleColor(1);
        
#if DEBUG_GROUP_NODE
        else if (isGrouped)
            ed::PopStyleColor(1);
#endif
#if DEBUG_NODE_DRAWING
        ImGui::Debug_DrawItemRect();
#endif
        // [Debug Overlay] Show cursor over node
        if (m_DebugOverlay) m_DebugOverlay->DrawNode(this, *node);
    }

    // Commit all links to editor
    CommitLinksToEditor();

    // Handle clone node
    if (need_clone_node)
    {
        ed::Suspend();
        LOGI("[HandleNodeToolBar] Clone from %" PRI_node, FMT_node(need_clone_node));
        auto nodeStart = ed::GetNodePosition(need_clone_node->m_ID);
        auto clone_node = m_Document->m_Blueprint.CloneNode(need_clone_node);
        ed::SetNodePosition(clone_node->m_ID, ImVec2(nodeStart.x + 40, nodeStart.y + 80));
        ed::Resume();
    }
    bool isThreadExecuting = m_Document->m_Blueprint.IsExecuting();
    bool isThreadPaused = m_Document->m_Blueprint.IsPaused();
    if (isThreadExecuting && !isThreadPaused && m_DebugOverlay && !m_isChildWindow)
    {
        g_Mutex.lock();
        m_Document->m_Blueprint.SetContextMonitor(m_DebugOverlay->GetContextMonitor());
        m_Document->m_Blueprint.ShowFlow();
        m_Document->m_Blueprint.SetContextMonitor(nullptr);
        g_Mutex.unlock();
    }

    // Handle new node menu last line drawing
    if (m_isNewNodePopuped && m_newNodeLinkPin != nullptr)
    {
        ed::DrawLastLine(m_Style == BluePrintStyle::BP_Style_Light);
    }
    if (m_DebugOverlay) m_DebugOverlay->End();
}

void BluePrintUI::DrawInfoTooltip()
{
    if (!m_Document || !ed::IsActive())
        return;

    auto hoveredNode = m_Document->m_Blueprint.FindNode(static_cast<ID_TYPE>(ed::GetHoveredNode().Get()));
    auto hoveredPin  = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(ed::GetHoveredPin().Get()));
    if (!hoveredNode && hoveredPin)
        hoveredNode = hoveredPin->m_Node;
    
    auto pinTooltip = [](const char* label, const Pin* pin, bool showNode)
    {
        ImGui::PushStyleColor(ImGuiCol_Separator, ImVec4(1,1,1,1));
        auto isDummy = pin->m_Node->GetStyle() == NodeStyle::Dummy;
        ImGui::Text("%s", label); ImGui::SameLine();
        ImGui::Text("%s", !pin->m_Name.empty() ? pin->m_Name.c_str() : "");
        ImGui::Bullet(); ImGui::Text("      ID: %u", pin->m_ID);
        if (pin->m_Link)
        {
            if (pin->m_Type == PinType::Flow)
                ImGui::Text("          ->: %u", pin->m_Link);
            else
                ImGui::Text("          <-: %u", pin->m_Link);
        }
        for (auto link_from : pin->m_LinkFrom)
        {
            if (pin->m_Type == PinType::Flow)
                ImGui::Text("          <-: %u", link_from);
            else
                ImGui::Text("          ->: %u", link_from);
        }
        if (pin->m_MappedPin)
        {
            ImGui::TextUnformatted("      "); ImGui::SameLine(); ImGui::TextUnformatted("Mapped:"); ImGui::SameLine();
            ImGui::Text(" %u", pin->m_MappedPin);
        }

        if (showNode && pin->m_Node)
        {
            auto nodeName = !isDummy ? pin->m_Node->GetName() : ((DummyNode *)pin->m_Node)->m_name + "*load fail*";
            ImGui::Bullet(); ImGui::TextUnformatted("      "); ImGui::SameLine(); ImGui::TextUnformatted("Node:"); ImGui::SameLine();
            ImGui::Text(" %" PRI_sv, FMT_sv(nodeName));
        }
        ImGui::Bullet(); ImGui::TextUnformatted("      Type:"); ImGui::SameLine();
        ImGui::Text("%s", PinTypeToString(pin->GetType()).c_str());
        ImGui::Bullet(); ImGui::TextUnformatted("Value Type:"); ImGui::SameLine();
        ImGui::Text("%s", PinTypeToString(pin->GetValueType()).c_str());
        if (!isDummy && !pin->m_MappedPin && pin->GetValueType() == PinType::Mat)
        {
            ImGui::Separator();
            ImGui::Bullet(); ImGui::TextUnformatted("Mat Info");
            pin->m_Node->m_mutex.lock();
            PinValue pinValue;
            if (!pin->IsInput())
            {
                pinValue = pin->GetValue();
            }
            else
            {
                auto bp = pin->m_Node->m_Blueprint;
                if (bp)
                {
                    auto link = pin->GetLink(bp);
                    while (link && link->IsMappedPin())
                        link = link->GetLink(bp);
                    if (link)
                    {
                        auto isLinkDummy = link->m_Node->GetStyle() == NodeStyle::Dummy;
                        if (!isLinkDummy)
                        {
                            link->m_Node->m_mutex.lock();
                            pinValue = link->GetValue();
                            link->m_Node->m_mutex.unlock();
                        }
                    }
                }
            }
            pin->m_Node->m_mutex.unlock();
            ImGui::ImMat mat;
            if (pinValue.GetType() == PinType::Mat)
                mat = pinValue.As<ImGui::ImMat>();
            if (!mat.empty())
            {
                ImGui::TextUnformatted("        Width:"); ImGui::SameLine(); ImGui::Text("%d", mat.w);
                ImGui::TextUnformatted("       Height:"); ImGui::SameLine(); ImGui::Text("%d", mat.h);
                ImGui::TextUnformatted("     Channels:"); ImGui::SameLine(); ImGui::Text("%d", mat.c);
                ImGui::TextUnformatted("       Device:"); ImGui::SameLine(); ImGui::Text("%s", mat.device == IM_DD_CPU ? "CPU" : 
                                                                                                mat.device == IM_DD_VULKAN ? "Vulkan" :
                                                                                                mat.device == IM_DD_VULKAN_IMAGE ? "Vulkan Image" : "Cuda");
                if (mat.device != 0)
                {
                    ImGui::TextUnformatted("          GPU:"); ImGui::SameLine(); ImGui::Text("%d", mat.device_number);
                }
                ImGui::TextUnformatted("    Data type:"); ImGui::SameLine(); ImGui::Text("%s", mat.type == IM_DT_INT8 ? "Int8" :
                                                mat.type == IM_DT_INT16 ? "Int16" :
                                                mat.type == IM_DT_INT16_BE ? "Int16BE" :
                                                mat.type == IM_DT_INT32 ? "Int32" :
                                                mat.type == IM_DT_INT64 ? "Int64" :
                                                mat.type == IM_DT_FLOAT16 ? "Float 16" : 
                                                mat.type == IM_DT_FLOAT32 ? "Float" :
                                                mat.type == IM_DT_FLOAT64 ? "Double" : "Unknown");
                ImGui::TextUnformatted("       Format:"); ImGui::SameLine(); ImGui::Text("%s", mat.flags & IM_MAT_FLAGS_AUDIO_FRAME ? "Audio" :
                                                mat.color_format == IM_CF_GRAY ? "Gray/Mono" :
                                                mat.color_format == IM_CF_BGR ? "BGR" :
                                                mat.color_format == IM_CF_ABGR ? "ABGR" :
                                                mat.color_format == IM_CF_BGRA ? "BGRA" :
                                                mat.color_format == IM_CF_RGB ? "RGB" :
                                                mat.color_format == IM_CF_ARGB ? "ARGB" :
                                                mat.color_format == IM_CF_RGBA ? "RGBA" :
                                                mat.color_format == IM_CF_YUV420 ? "YUV420" :
                                                mat.color_format == IM_CF_YUV422 ? "YUV422" :
                                                mat.color_format == IM_CF_YUV440 ? "YUV440" :
                                                mat.color_format == IM_CF_YUV444 ? "YUV444" :
                                                mat.color_format == IM_CF_YUVA ? "YUVA" :
                                                mat.color_format == IM_CF_NV12 ? "NV12" : 
                                                mat.color_format == IM_CF_P010LE ? "P010LE" :"Unknown");
                if (mat.flags & IM_MAT_FLAGS_VIDEO_FRAME)
                {
                    ImGui::TextUnformatted("   Frame Type:"); ImGui::SameLine(); ImGui::Text("%s", mat.flags & IM_MAT_FLAGS_VIDEO_FRAME_I ? "I" : 
                                                    mat.flags & IM_MAT_FLAGS_VIDEO_FRAME_P ? "P" : 
                                                    mat.flags & IM_MAT_FLAGS_VIDEO_FRAME_B ? "B" : "Unknown");
                    ImGui::TextUnformatted("    Frame HDR:"); ImGui::SameLine(); ImGui::Text("%s", mat.flags & IM_MAT_FLAGS_VIDEO_HDR_PQ ? "PQ" : 
                                                    mat.flags & IM_MAT_FLAGS_VIDEO_HDR_HLG ? "HLG" : "SDR");
                    ImGui::TextUnformatted("   Interlaced:"); ImGui::SameLine(); ImGui::Text("%s", mat.flags & IM_MAT_FLAGS_VIDEO_INTERLACED ? "Interlaced" : "no");
                }
                ImGui::TextUnformatted("    TimeStamp:"); ImGui::SameLine(); ImGui::Text("%.6f", mat.time_stamp);
            }
            else
            {
                ImGui::TextUnformatted("      *Empty*");
            }
            ImGui::Separator();
        }
        if (!isDummy && !pin->m_MappedPin && pin->GetValueType() == PinType::Array)
        {
            ImGui::Separator();
            ImGui::Bullet(); ImGui::TextUnformatted("Array Info");
            pin->m_Node->m_mutex.lock();
            PinValue pinValue;
            if (!pin->IsInput())
            {
                pinValue = pin->GetValue();
            }
            else
            {
                auto bp = pin->m_Node->m_Blueprint;
                if (bp)
                {
                    auto link = pin->GetLink(bp);
                    while (link && link->IsMappedPin())
                        link = link->GetLink(bp);
                    if (link)
                    {
                        auto isLinkDummy = link->m_Node->GetStyle() == NodeStyle::Dummy;
                        if (!isLinkDummy)
                        {
                            link->m_Node->m_mutex.lock();
                            pinValue = link->GetValue();
                            link->m_Node->m_mutex.unlock();
                        }
                    }
                }
            }
            pin->m_Node->m_mutex.unlock();
            imgui_json::array array;
            if (pinValue.GetType() == PinType::Array)
                array = pinValue.As<imgui_json::array>();
            if (array.size() > 0)
            {
                auto type = array[0].type();
                ImGui::TextUnformatted("        Element Size:"); ImGui::SameLine(); ImGui::Text("%zu", array.size());
                ImGui::TextUnformatted("        Element Type:"); ImGui::SameLine(); ImGui::Text("%s", edd::Serialization::ToString(type).c_str());
            }
            else
            {
                ImGui::TextUnformatted("      *Empty*");
                ImGui::TextUnformatted("             ");
            }
            ImGui::Separator();
        }
        std::vector<std::string> flags;
        if (pin->IsMappedPin())
            flags.push_back("mapped");
        if (pin->m_Flags & PIN_FLAG_EXPORTED)
            flags.push_back("exported");
        if (pin->m_Flags & PIN_FLAG_PUBLICIZED)
            flags.push_back("publicized");
        if (pin->IsLinked())
            flags.push_back("linked");
        if (pin->IsInput())
            flags.push_back("input");
        if (pin->IsOutput())
            flags.push_back("output");
        if (pin->IsProvider())
            flags.push_back("provider");
        if (pin->IsReceiver())
            flags.push_back("receiver");
        ImGui::Bullet();
        ImGui::TextUnformatted("   Flags:"); ImGui::SameLine(); 
        for (auto flag : flags)
        {
            ImGui::Text("%s", flag.c_str());
            ImGui::SameLine();
        }
        ImGui::TextUnformatted("");

        ImGui::PopStyleColor();
    };

    if (hoveredNode)
    {
        auto isDummy = hoveredNode->GetStyle() == NodeStyle::Dummy;
        auto nodeTypeInfo = hoveredNode->GetTypeInfo();
        auto nodeName = !isDummy ? hoveredNode->GetName() : ((DummyNode *)hoveredNode)->m_name + "*load fail*";
        auto nodeTypeName = !isDummy ? nodeTypeInfo.m_Name : ((DummyNode *)hoveredNode)->m_type_name;
        auto nodeType = !isDummy ? hoveredNode->GetType() : ((DummyNode *)hoveredNode)->m_type;
        auto nodeStyle = !isDummy ? hoveredNode->GetStyle() : ((DummyNode *)hoveredNode)->m_style;
        auto nodeCatalog = !isDummy ? hoveredNode->GetCatalog() : ((DummyNode *)hoveredNode)->m_catalog;
        auto nodeVersion = nodeTypeInfo.m_Version;
        auto nodeSDKVersion = nodeTypeInfo.m_SDK_Version;
        auto nodeAPIVersion = nodeTypeInfo.m_API_Version;
        auto nodeAuthor = nodeTypeInfo.m_Author;
        auto nodeURL = !isDummy ? (hoveredNode->GetURL().empty() ? "Internal" : hoveredNode->GetURL()) : "Missing"; // must call GetURL from regiested node type info list
        ed::Suspend();
        if (hoveredNode->m_IconHovered >= 0 && ImGui::BeginTooltip())
        {
            ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.75f);
            switch (hoveredNode->m_IconHovered)
            {
                case 0: ImGui::TextUnformatted("Node Clone"); break;
                case 1: ImGui::TextUnformatted("Node Delete"); break;
                case 2: ImGui::TextUnformatted("Node Setting"); break;
                case 3: ImGui::TextUnformatted("Save Group"); break;
                case 4: if (hoveredNode->m_Enabled) ImGui::TextUnformatted("Disable"); else ImGui::TextUnformatted("Enable"); break;
                default: break;
            }
            ImGui::PopStyleVar();
            ImGui::EndTooltip();
        }
        else if (m_isShowInfoTooltips && ImGui::BeginTooltip())
        {
            if (hoveredPin)
            {
                if (ImGui::IsMouseDoubleClicked(0))
                {
                    LOGI("[Pin Event:] %" PRI_pin " be double clicked", FMT_pin(hoveredPin));
                    if (!hoveredPin->IsMappedPin())
                    {
                        if (hoveredPin->m_Flags & PIN_FLAG_PUBLICIZED)
                        {
                            hoveredPin->m_Flags &= ~PIN_FLAG_PUBLICIZED;
                        }
                        else
                        {
                            hoveredPin->m_Flags |= PIN_FLAG_PUBLICIZED;
                        }
                        ed::SetPinChanged(hoveredPin->m_ID);
                        File_MarkModified();
                    }
                }
                pinTooltip("Pin:", hoveredPin, false);
                ImGui::Separator();
            }
            ImGui::TextUnformatted("Node:"); ImGui::SameLine(); ImGui::Text("%" PRI_sv, FMT_sv(nodeName));
            ImGui::Bullet(); ImGui::TextUnformatted("   Node ID:"); ImGui::SameLine(); ImGui::Text("%u", hoveredNode->m_ID);
            ImGui::Bullet(); ImGui::TextUnformatted("   Type ID:"); ImGui::SameLine(); ImGui::Text("0x%08" PRIX32, nodeTypeInfo.m_ID);
            ImGui::Bullet(); ImGui::TextUnformatted("  TypeName:"); ImGui::SameLine(); ImGui::Text("%" PRI_sv, FMT_sv(nodeTypeName));
            ImGui::Bullet(); ImGui::TextUnformatted("    Author:"); ImGui::SameLine(); ImGui::Text("%" PRI_sv, FMT_sv(nodeAuthor));
            ImGui::Bullet(); ImGui::TextUnformatted("   Version:"); ImGui::SameLine(); ImGui::Text("%" PRI_sv, FMT_sv(NodeVersionToString(nodeVersion)));
            ImGui::Bullet(); ImGui::TextUnformatted("SDKVersion:"); ImGui::SameLine(); ImGui::Text("%" PRI_sv, FMT_sv(NodeVersionToString(nodeSDKVersion)));
            ImGui::Bullet(); ImGui::TextUnformatted("APIVersion:"); ImGui::SameLine(); ImGui::Text("%" PRI_sv, FMT_sv(NodeVersionToString(nodeAPIVersion)));
            ImGui::Bullet(); ImGui::TextUnformatted("      Type:"); ImGui::SameLine(); ImGui::Text("%s", NodeTypeToString(nodeType).c_str());
            ImGui::Bullet(); ImGui::TextUnformatted("     Style:"); ImGui::SameLine(); ImGui::Text("%s", NodeStyleToString(nodeStyle).c_str());
            ImGui::Bullet(); ImGui::TextUnformatted("       URL:"); ImGui::SameLine(); ImGui::Text("%" PRI_sv, FMT_sv(nodeURL));
            
            ImGui::Bullet(); ImGui::TextUnformatted("   Catalog:"); ImGui::SameLine();
            auto catalogs = BluePrint::GetCatalogInfo(nodeCatalog);
            for (auto catalog : catalogs)
            {
                ImGui::Text("%s", catalog.c_str()); ImGui::SameLine();
            }
            ImGui::TextUnformatted("");
            
            ImGui::Bullet(); ImGui::TextUnformatted("     Z-Pos:"); ImGui::SameLine(); ImGui::Text("%.1f", ed::GetNodeZPosition(hoveredNode->m_ID));
            if (hoveredNode->m_GroupID != 0)
            {
                ImGui::Bullet(); ImGui::TextUnformatted("   Grouped:"); ImGui::SameLine(); ImGui::Text("0x%08" PRIX32, hoveredNode->m_GroupID);
            }
            else
            {
                ImGui::Bullet(); ImGui::TextUnformatted(" Non-Grouped");
            }
            //if (m_Document->m_Blueprint.IsExecuting())
            {
                ImGui::Separator();
                ImGui::Bullet(); ImGui::TextUnformatted("      Hits:"); ImGui::SameLine(); ImGui::Text("%s", std::to_string(hoveredNode->m_Hits).c_str());
                std::ostringstream oss;
                oss << std::setprecision(hoveredNode->m_Tick > 1000 ? 6 : 3) << (hoveredNode->m_Tick > 1000000 ? hoveredNode->m_Tick / 1000000.0 :
                                        hoveredNode->m_Tick > 1000 ? hoveredNode->m_Tick / 1000.0 :
                                        hoveredNode->m_Tick);
                std::string consuming_text = oss.str() + (hoveredNode->m_Tick > 1000000 ? "s" : hoveredNode->m_Tick > 1000 ? "ms" : "us");
                ImGui::Bullet(); ImGui::TextUnformatted(" Consuming:"); ImGui::SameLine(); ImGui::Text("%s", consuming_text.c_str());
                ImGui::Bullet(); ImGui::TextUnformatted(" Node Time:"); ImGui::SameLine(); ImGui::Text("%.3fms (avg: %.3fms)", hoveredNode->m_NodeTimeMs, hoveredNode->m_AvgTimeMs);
            }
            ImGui::EndTooltip();
        }
        ed::Resume();
    }
    else if (auto hoveredLinkId = ed::GetHoveredLink())
    {
        if (m_isShowInfoTooltips)
        {
            ed::PinId firstPinId, secondPinId;
            ed::GetLinkPins(hoveredLinkId, &firstPinId, &secondPinId);
            // inverse flow pin order since we create link using sample mode
            Pin * startPin = nullptr;
            Pin * endPin = nullptr;
            auto firstPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(firstPinId.Get()));
            auto secondPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(secondPinId.Get()));
            if (firstPin && secondPin)
            {
                auto isFirstDummy = firstPin->m_Node->GetStyle() == NodeStyle::Dummy;
                auto isSecondDummy = secondPin->m_Node->GetStyle() == NodeStyle::Dummy;
                if (!isFirstDummy && !isSecondDummy)
                {
                    if (firstPin->GetType() == PinType::Flow && secondPin->GetType() == PinType::Flow)
                    {
                        startPin = firstPin;
                        endPin = secondPin;
                    }
                    else
                    {
                        startPin = secondPin;
                        endPin = firstPin;
                    }
                    ed::Suspend();
                    if (ImGui::BeginTooltip())
                    {
                        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, 0.75f);
                        ImGui::Text("Link ID: 0x%08" PRIX32, startPin->m_ID);
                        ImGui::Text("Type: %s", PinTypeToString(startPin->GetValueType()).c_str());
                        ImGui::Separator();
                        pinTooltip("Start Pin:", startPin, true);
                        ImGui::Separator();
                        pinTooltip("End Pin:", endPin, true);
                        ImGui::PopStyleVar();
                        ImGui::EndTooltip();
                    }
                    ed::Resume();
                }
            }
        }
    }
}

void BluePrintUI::ShowDialogs()
{
    if (!m_Document)
        return;
    ed::Suspend();
    m_ContextMenu.Show(*this);
    m_NodeContextMenu.Show(*this);
    m_PinContextMenu.Show(*this);
    m_LinkContextMenu.Show(*this);
    m_NodeDeleteDialog.Show(*this);
    m_NodeCreateDialog.Show(*this);
    m_NodeSettingDialog.Show(*this);
    ed::Resume();
}

void BluePrintUI::FileDialogs()
{
    if (!m_Document)
        return;
    auto& io = ImGui::GetIO();
    auto viewport = ImGui::GetWindowViewport();
    ImVec2 maxSize = viewport->Size;
    ImVec2 minSize = maxSize * 0.5f;
     // modify by dicky, if using multiviewport, make sure we display on top
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        io.ConfigViewportsNoDecoration = true;
        const ImGuiViewportP* viewport = (ImGuiViewportP*) ImGui::GetWindowViewport();
        ImGui::SetNextWindowViewport(viewport->ID);
    }
    // modify by dicky end
    if (ImGuiFileDialog::Instance()->Display("##BlueprintUI##OpenFileDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
    {
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            string error;
            auto filePathName = ImGuiFileDialog::Instance()->GetFilePathName();
            if (!File_Open(filePathName, &error) && !error.empty())
            {
                LOGE("%s", error.c_str());
            }
        }
        ImGuiFileDialog::Instance()->Close();
    }
    if (ImGuiFileDialog::Instance()->Display("##BlueprintUI##SaveFileDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
	{
        if (ImGuiFileDialog::Instance()->IsOk())
		{
            auto filePathName = ImGuiFileDialog::Instance()->GetFilePathName();
            if (!File_SaveAsEx(filePathName))
            {
                LOGE("Save file failed %s", filePathName.c_str());
            }
            else
            {
                m_Document->SetPath(filePathName);
                if (!m_isChildWindow)
                {
                    auto mostRecentlyOpenFiles = ImGui::MostRecentlyUsedList("BluePrintOpenList");
                    mostRecentlyOpenFiles.Add(filePathName);
                }
            }
        }
        ImGuiFileDialog::Instance()->Close();
    }
    if (ImGuiFileDialog::Instance()->Display("##BlueprintUI##SaveGroupDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
    {
        if (ImGuiFileDialog::Instance()->IsOk())
		{
            GroupNode * node = (GroupNode *)ImGuiFileDialog::Instance()->GetUserDatas();
            auto filePathName = ImGuiFileDialog::Instance()->GetFilePathName();
            if (node)
            {
                node->SaveGroup(filePathName);
            }
        }
        ImGuiFileDialog::Instance()->Close();
    }
    if (ImGuiFileDialog::Instance()->Display("##BlueprintUI##ImportGroupDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
    {
        if (ImGuiFileDialog::Instance()->IsOk())
        {
            string error;
            auto filePathName = ImGuiFileDialog::Instance()->GetFilePathName();
            ImVec2 * pos = (ImVec2 *)ImGuiFileDialog::Instance()->GetUserDatas();
            if (!File_Import(filePathName, *pos, &error) && !error.empty())
            {
                LOGE("%s", error.c_str());
            }
        }
        ImGuiFileDialog::Instance()->Close();
    }
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        io.ConfigViewportsNoDecoration = false;
}

Node* BluePrintUI::ShowNewNodeMenu(ImVec2 popupPosition, std::string catalog_filter)
{
    Node* node = nullptr;
    if (!m_Document)
        return node;
    static string filter_string = "";
    ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.0f);
    if (ImGui::InputText(ICON_NODE_SEARCH "##search_string_value", (char*)filter_string.data(), filter_string.size() + 1, ImGuiInputTextFlags_CallbackEdit | ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_CallbackResize, [](ImGuiInputTextCallbackData* data) -> int
    {
        if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)
        {
            auto& stringValue = *static_cast<string*>(data->UserData);
            ImVector<char>* my_str = (ImVector<char>*)data->UserData;
            IM_ASSERT(stringValue.data() == data->Buf);
            stringValue.resize(data->BufSize);
            data->Buf = (char*)stringValue.data();
        }
        else if (data->EventFlag == ImGuiInputTextFlags_CallbackEdit)
        {
            auto& stringValue = *static_cast<string*>(data->UserData);
            stringValue = std::string(data->Buf);
        }
        return 0;
    }, &filter_string))
    {
        filter_string.resize(strlen(filter_string.c_str()));
    }
    ImGui::PopStyleVar();
    ImGui::Separator();
    auto registryNode = m_Document->m_Blueprint.GetNodeRegistry()->GetTypes();
    auto registryCatalog = m_Document->m_Blueprint.GetNodeRegistry()->GetCatalogs();
    bool need_root = true;
    int start_level = 0;
    std::vector<const BluePrint::NodeTypeInfo*> nodes;
    if (!catalog_filter.empty())
    {
        auto catalog_filters = GetCatalogInfo(catalog_filter);
        if (catalog_filters.size() > 0)
        {
            need_root = false;
            start_level = catalog_filters.size();
        }
        std::vector<const NodeTypeInfo *> array;
        for (auto nodetype : registryNode)
        {
            auto catalogs = GetCatalogInfo(nodetype->m_Catalog);
            if (catalogs.size() > 0 && catalog_filters.size() > 0 && catalogs[0].compare("Dummy") != 0)
            {
                if (catalogs[0].compare(catalog_filters[0]) == 0)
                {
                    if (catalogs.size() > 1 && catalog_filters.size() > 1)
                    {
                        if (catalogs[1].compare(catalog_filters[1]) == 0)
                        {
                            if (catalogs.size() > 2 && catalog_filters.size() > 2)
                            {
                                if (catalogs[2].compare(catalog_filters[2]) == 0)
                                    array.push_back(nodetype);
                            }
                            else
                                array.push_back(nodetype);
                        }
                    }
                    else
                        array.push_back(nodetype);
                }
                else if (nodetype->m_Style == NodeStyle::Comment || nodetype->m_Style == NodeStyle::Group)
                {
                    array.push_back(nodetype);
                }
            }
        }
        string low_case_filter_str = filter_string.size() > 0 ? to_lower(filter_string) : "";
        for (auto nodetype : array)
        {
            string low_case_node_type_name = to_lower(nodetype->m_Name);
            if (filter_string.size() == 0 || low_case_node_type_name.find(low_case_filter_str) != string::npos)
            {
                nodes.push_back(nodetype);
            }
        }
    }
    else if (filter_string.size() > 0)
    {
        string low_case_filter_str = to_lower(filter_string);
        for (size_t i = 0; i < registryCatalog.size(); i++)
        {
            auto catalog = registryCatalog[i];
            std::vector<const NodeTypeInfo *> array;
            for (auto nodetype : registryNode)
            {
                auto catalogs = GetCatalogInfo(nodetype->m_Catalog);
                if (catalogs.size() > 0 && catalogs[0].compare("Dummy") != 0 && catalogs[0].compare(catalog) == 0)
                    array.push_back(nodetype);
            }
            for (auto nodetype : array)
            {
                string low_case_node_type_name = to_lower(nodetype->m_Name);
                if (low_case_node_type_name.find(low_case_filter_str) != string::npos)
                {
                    nodes.push_back(nodetype);
                }
            }
        }
    }
    else
    {
        for (auto nodetype : registryNode)
        {
            if (nodetype->m_Catalog.compare("Dummy") != 0)
                nodes.push_back(nodetype);
        }
    }
    std::sort(nodes.begin(), nodes.end(), [](const NodeTypeInfo * a, const NodeTypeInfo * b) {
        return a->m_Name < b->m_Name;
    });

    auto AddNodeMenu = [&](void* data, bool tree_view = true, bool is_system_node = false)
    {
        const BluePrint::NodeTypeInfo* nodetype = (const BluePrint::NodeTypeInfo*)data;
        std::string menu_label;
        if (tree_view)
        {
            if (is_system_node)
            {
                ImGui::TextUnformatted(ICON_BP_ZOOM_IN); 
                ImGui::SameLine();
            }
            else 
                ImGui::Bullet();
            menu_label = nodetype->m_Name;
        }
        else
        {
            auto catalogs = GetCatalogInfo(nodetype->m_Catalog);
            for (auto label : catalogs)
                menu_label += label + " " + ICON_NODE_NEXT + " ";
            menu_label += nodetype->m_Name;
        }
        
        if (ImGui::MenuItem(menu_label.c_str(), nullptr, false, true, nodetype->m_Type == NodeType::External ? ICON_NODE_DLL : nullptr))
        {
            auto transaction = m_Document->BeginUndoTransaction("CreateNode");
            BeginOpRecord("CreateNode");
            node = m_Document->m_Blueprint.CreateNode(nodetype->m_ID);
            LOGI("[NodeCreate] %" PRI_node " created", FMT_node(node));
            if (popupPosition.x == 0 || popupPosition.y == 0)
            {
                ImVec2 w_pos = ImGui::GetCursorPos();
                ImVec2 c_pos = ImGui::GetWindowPos();
                popupPosition = ImVec2(w_pos.x + c_pos.x, w_pos.y + c_pos.y);
            }
            auto nodePosition = ed::ScreenToCanvas(popupPosition);
            ed::SetNodePosition(node->m_ID, nodePosition);
            ed::SelectNode(node->m_ID);
            transaction->AddAction("%" PRI_node " created", FMT_node(node));
            m_isNewNodePopuped = false;
            m_newNodeLinkPin = nullptr;
        }
    };

    if (filter_string.size() > 0)
    {
        for (auto nodetype : nodes)
        {
            AddNodeMenu((void *)nodetype, false);
        }
    }
    else
    {
        // make node type as tree, max 4 levels
        ImGui::ImTree node_tree;
        node_tree.name = "Nodes";
        if (need_root)
        {
            for (size_t i = 0; i < registryCatalog.size(); i++)
            {
                auto catalog = registryCatalog[i];
                auto catalogs = GetCatalogInfo(catalog);
                if (catalogs.size() > 0 && catalogs[0].compare("Dummy") != 0)
                {
                    auto children = node_tree.FindChildren(catalogs[0]);
                    if (!children)
                    {
                        ImGui::ImTree subtree(catalogs[0]);
                        node_tree.childrens.push_back(subtree);
                    }
                }
            }
        }
        for (auto type : nodes)
        {
            auto catalog = BluePrint::GetCatalogInfo(type->m_Catalog);
            if (!catalog.size())
                continue;
            ImGui::ImTree * root = need_root ? node_tree.FindChildren(catalog[0]) : &node_tree;
            if (catalog.size() > 1)
            {
                auto children = root->FindChildren(catalog[1]);
                if (!children)
                {
                    ImGui::ImTree subtree(catalog[1]);
                    if (catalog.size() > 2)
                    {
                        ImGui::ImTree sub_sub_tree(catalog[2]);
                        ImGui::ImTree end_sub(type->m_Name, (void *)type);
                        sub_sub_tree.childrens.push_back(end_sub);
                        subtree.childrens.push_back(sub_sub_tree);
                    }
                    else
                    {
                        ImGui::ImTree end_sub(type->m_Name, (void *)type);
                        subtree.childrens.push_back(end_sub);
                    }

                    root->childrens.push_back(subtree);
                }
                else
                {
                    if (catalog.size() > 2)
                    {
                        auto sub_children = children->FindChildren(catalog[2]);
                        if (!sub_children)
                        {
                            ImGui::ImTree subtree(catalog[2]);
                            ImGui::ImTree end_sub(type->m_Name, (void *)type);
                            subtree.childrens.push_back(end_sub);
                            children->childrens.push_back(subtree);
                        }
                        else
                        {
                            ImGui::ImTree end_sub(type->m_Name, (void *)type);
                            sub_children->childrens.push_back(end_sub);
                        }
                    }
                    else
                    {
                        ImGui::ImTree end_sub(type->m_Name, (void *)type);
                        children->childrens.push_back(end_sub);
                    }
                }
            }
            else
            {
                ImGui::ImTree end_sub(type->m_Name, (void *)type);
                root->childrens.push_back(end_sub);
            }
        }

        // draw node tree
        ImGui::ImTree * start = &node_tree;
        for (int i = 0; i < start_level - 1; i++)
        {
            for (int j = 0; j < start->childrens.size(); j++)
            {
                if (start->childrens[j].data)
                    continue;
                else
                {
                    start = &start->childrens[j];
                    break;
                }
            }
        }

        for (auto sub : start->childrens)
        {
            if (sub.data)
            {
                AddNodeMenu(sub.data);
            }
            else if (ImGui::BeginMenu(sub.name.c_str()))
            {
                for (auto sub_2 : sub.childrens)
                {
                    if (sub_2.data)
                    {
                        AddNodeMenu(sub_2.data);
                    }
                    else if (ImGui::BeginMenu(sub_2.name.c_str()))
                    {
                        for (auto sub_3 : sub_2.childrens)
                        {
                            if (sub_3.data)
                            {
                                AddNodeMenu(sub_3.data);
                            }
                            else if (ImGui::BeginMenu(sub_3.name.c_str()))
                            {
                                for (auto sub_4 : sub_3.childrens)
                                {
                                    if (sub_4.data)
                                    {
                                        AddNodeMenu(sub_4.data);
                                    }
                                    else
                                    {
                                        continue;
                                    }
                                }
                                ImGui::EndMenu();
                            }
                        }
                        ImGui::EndMenu();
                    }
                }
                ImGui::EndMenu();
            }
        }

        // draw utils node
        if (&node_tree != start)
        {
            for (auto sub : node_tree.childrens)
            {
                if (sub.data)
                {
                    AddNodeMenu(sub.data, true, true);
                }
            }
        }
    }
    return node;
}

void BluePrintUI::HandleCreateAction(uint32_t flag)
{
    if (!m_Document)
        return;

    ItemBuilder itemBuilder;
    if (!itemBuilder)
        return;

    m_isNewNodePopuped = false;
    m_newNodeLinkPin = nullptr;

    if (auto linkBuilder = itemBuilder.QueryNewLink())
    {
        auto startPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(linkBuilder->m_StartPinId.Get()));
        auto endPin   = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(linkBuilder->m_EndPinId.Get()));
        // Editor return pins in order draw by the user. It is up to the
        // user to determine if it is valid. In blueprints we accept only links
        // from receivers to providers. Other graph types may allow bi-directional
        // links between nodes and this ordering make this feature possible.
        if (endPin->IsReceiver() && startPin->IsProvider())
            ImSwap(startPin, endPin);
        if (auto canLinkResult = startPin->CanLinkTo(*endPin))
        {
            ed::Suspend();
            if (ImGui::BeginTooltip())
            {
                ImGui::TextUnformatted("Valid Link"); ImGui::SameLine();
                if (!canLinkResult.Reason().empty())
                {
                    ImGui::TextUnformatted(": "); ImGui::SameLine();
                    ImGui::Text("%s", canLinkResult.Reason().c_str());
                }
                ImGui::Separator();
                ImGui::TextUnformatted("From:");
                ImGui::Bullet(); ImGui::Text("%" PRI_pin, FMT_pin(startPin));
                ImGui::Bullet(); ImGui::Text("%" PRI_node, FMT_node(startPin->m_Node));
                ImGui::TextUnformatted("To:");
                ImGui::Bullet(); ImGui::Text("%" PRI_pin, FMT_pin(endPin));
                ImGui::Bullet(); ImGui::Text("%" PRI_node, FMT_node(endPin->m_Node));
                ImGui::EndTooltip();
            }
            ed::Resume();
            if (linkBuilder->Accept())
            {
                auto transaction = m_Document->BeginUndoTransaction("Create Link");
                if (startPin->LinkTo(*endPin))
                {
                    LOGI("[HandleCreateAction] %" PRI_pin " linked with %" PRI_pin, FMT_pin(startPin), FMT_pin(endPin));
                    if (m_CallBacks.BluePrintOnChanged)
                    {
                        auto ret = m_CallBacks.BluePrintOnChanged(BP_CB_Link, m_Document->m_Name, m_UserHandle);
                        if (startPin->m_Type == PinType::Flow && ret == BP_CBR_AutoLink)
                        {
                            auto out_pin = startPin->m_Node->GetAutoLinkOutputDataPin();
                            auto in_pin = endPin->m_Node->GetAutoLinkInputDataPin();
                            if (in_pin.size() && out_pin.size() && in_pin.size() == out_pin.size())
                            {
                                for (int i = 0; i < in_pin.size(); i++)
                                {
                                    in_pin[i]->LinkTo(*out_pin[i]);
                                }
                            }
                        }
                    }
                }
                else
                    transaction->Discard();
            }
        }
        else
        {
            ed::Suspend();
            if (ImGui::BeginTooltip())
            {
                ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1,0 ,0 ,1));
                ImGui::TextUnformatted("Invalid Link:"); ImGui::SameLine();
                ImGui::Text("%s", canLinkResult.Reason().c_str());
                ImGui::PopStyleColor();
                ImGui::EndTooltip();
            }
            ed::Resume();
            linkBuilder->Reject();
        }
    }
    else if (auto nodeBuilder = itemBuilder.QueryNewNode())
    {
        // Arguably creation of node is simpler than a link.
        ed::Suspend();
        ImGui::SetTooltip("Create Node...");
        ed::Resume();
        // Node builder accept return true when user release mouse button.
        // When this happen we request CreateNodeDialog to open.
        if (nodeBuilder->Accept())
        {
            // Get node from which link was pulled (if any). After creating
            // node we will try to make link with first matching pin of the node.
            auto pin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(nodeBuilder->m_PinId.Get()));
            ed::Suspend();
            LOGI("[HandleCreateAction] Open CreateNodeDialog");
            m_NodeCreateDialog.Open(pin, flag);
            m_isNewNodePopuped = true;
            m_newNodeLinkPin = pin;
            ed::Resume();
        }
    }
}

void BluePrintUI::HandleAutoLink(Node *node, vector<std::pair<Pin *, Pin *>>& relink_pairs)
{
    // need mark re-link pairs
    auto in_flow_pin = node->GetAutoLinkInputFlowPin();
    auto in_data_pin = node->GetAutoLinkInputDataPin();
    auto out_flow_pin = node->GetAutoLinkOutputFlowPin();
    auto out_data_pin = node->GetAutoLinkOutputDataPin();
    // Check flow pin relink pair 
    if (in_flow_pin && out_flow_pin &&
        in_flow_pin->m_LinkFrom.size() > 0 &&
        out_flow_pin->m_Link)
    {
        for (auto from_pin : in_flow_pin->m_LinkFrom)
        {
            std::pair<Pin *, Pin *> re_link;
            auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
            auto link_pin = m_Document->m_Blueprint.GetPinFromID(out_flow_pin->m_Link);
            if (pin && link_pin)
            {
                std::pair<Pin *, Pin *> re_link(pin, link_pin);
                relink_pairs.push_back(re_link);
            }
        }
    }
    // Check data pin relink pair 
    int pair_num = ImMin(in_data_pin.size(), out_data_pin.size());
    for (int i = 0; i < pair_num; i++)
    {
        auto in_pin = in_data_pin[i];
        auto out_pin = out_data_pin[i];
        if (in_pin->m_Link && out_pin->m_LinkFrom.size() > 0)
        {
            for (auto from_pin : out_pin->m_LinkFrom)
            {
                std::pair<Pin *, Pin *> re_link;
                auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
                auto link_pin = m_Document->m_Blueprint.GetPinFromID(in_pin->m_Link);
                if (pin && link_pin)
                {
                    std::pair<Pin *, Pin *> re_link(pin, link_pin);
                    relink_pairs.push_back(re_link);
                }
            }
        }
    }
}

void BluePrintUI::HandleAutoLink(Node *node, Node* input_node, Node* output_node)
{
    if (!node)
        return;
    if (input_node)
    {
        // link input pin
        auto input_flow_pin = input_node->GetAutoLinkOutputFlowPin();
        auto current_input_flow_pin = node->GetAutoLinkInputFlowPin();
        if (input_flow_pin && current_input_flow_pin)
        {
            input_flow_pin->LinkTo(*current_input_flow_pin);
        }
        auto input_data_pin = input_node->GetAutoLinkOutputDataPin();
        auto current_input_data_pin = node->GetAutoLinkInputDataPin();
        int link_num = ImMin(input_data_pin.size(), current_input_data_pin.size());
        for (int i = 0; i < link_num; i++)
        {
            current_input_data_pin[i]->LinkTo(*input_data_pin[i]);
        }
    }
    // link output pin
    if (output_node)
    {
        auto current_out_flow_pin = node->GetAutoLinkOutputFlowPin();
        auto output_flow_pin = output_node->GetAutoLinkInputFlowPin();
        if (current_out_flow_pin && output_flow_pin)
        {
            current_out_flow_pin->LinkTo(*output_flow_pin);
        }
        auto current_out_data_pin = node->GetAutoLinkOutputDataPin();
        auto output_data_pin = output_node->GetAutoLinkInputDataPin();
        int link_num = ImMin(current_out_data_pin.size(), output_data_pin.size());
        for (int i = 0; i < link_num; i++)
        {
            output_data_pin[i]->LinkTo(*current_out_data_pin[i]);
        }
    }   
}

void BluePrintUI::HandleAutoLink(Node *node, Pin* from_pin)
{
    if (!node)
        return;
    if (from_pin->GetType() == PinType::Flow)
    {
        auto flow_pin = node->GetAutoLinkInputFlowPin();
        if (flow_pin)
            from_pin->LinkTo(*flow_pin);
    }
    else
    {
        auto data_pins = node->GetAutoLinkInputDataPin();
        for (auto pin : data_pins)
        {
            if (auto canLinkResult = pin->CanLinkTo(*from_pin))
            {
                pin->LinkTo(*from_pin);
                break;
            }
        }
    }
}

void BluePrintUI::HandleDestroyAction()
{
    if (!m_Document)
        return;
    ItemDeleter itemDeleter;
    if (!itemDeleter)
        return;
    bool validDeletion = false;

    auto deferredTransaction = m_Document->GetDeferredUndoTransaction("Destroy Action");
    vector<Node*> nodesToDelete;
    uint32_t brokenLinkCount = 0;
    vector<std::pair<Pin *, Pin *>> relink_pairs;
    // Process all nodes marked for deletion
    while (auto nodeDeleter = itemDeleter.QueryDeletedNode())
    {
        deferredTransaction->Begin("Delete Item");
        auto node = m_Document->m_Blueprint.FindNode(static_cast<ID_TYPE>(nodeDeleter->m_NodeId.Get()));
        // Remove node, pass 'true' so links attached to node will also be queued for deletion.
        if (node && nodeDeleter->Accept(node->GetStyle() != NodeStyle::Group))
        {
            // Infor Node to handle delete before serv links
            node->OnNodeDelete();
            if (m_CallBacks.BluePrintOnChanged)
            {
                auto ret = m_CallBacks.BluePrintOnChanged(BP_CB_NODE_DELETED, m_Document->m_Name, m_UserHandle);
                if (ret == BP_CBR_AutoLink)
                {
                    HandleAutoLink(node, relink_pairs);
                }
            }
            // Queue nodes for deletion. We need to serve links first to avoid crash.
            nodesToDelete.push_back(node);
            validDeletion = true;
        }
    }
    // Process all links marked for deletion
    while (auto linkDeleter = itemDeleter.QueryDeleteLink())
    {
        deferredTransaction->Begin("Delete Item");
        if (linkDeleter->Accept())
        {
            auto pins = m_Document->m_Blueprint.GetPins();
            auto startPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(linkDeleter->m_StartPinId.Get()));
            if (startPin != nullptr && startPin->IsLinked())
            {
                auto linkedPin = startPin->GetLink();
                if (std::find(pins.begin(), pins.end(), linkedPin) != pins.end())
                {
                    LOGI("[HandleDestroyAction] %" PRI_pin " unlinked from %" PRI_pin, FMT_pin(startPin), FMT_pin(linkedPin));
                    startPin->Unlink();
                    if (m_CallBacks.BluePrintOnChanged)
                    {
                        auto ret = m_CallBacks.BluePrintOnChanged(BP_CB_Unlink, m_Document->m_Name, m_UserHandle);
                    }
                    ++brokenLinkCount;
                    validDeletion = true;
                }
            }
        }
    }
    // After links was removed, now it is safe to delete nodes.
    for (auto node : nodesToDelete)
    {
        LOGI("[HandleDestroyAction] %" PRI_node, FMT_node(node));
        m_Document->m_Blueprint.DeleteNode(node);
    }

    if (!nodesToDelete.empty() || brokenLinkCount)
    {
        LOGI("[HandleDestroyAction] %" PRIu32 " node%s deleted, %" PRIu32 " link%s broken",
            static_cast<uint32_t>(nodesToDelete.size()), nodesToDelete.size() != 1 ? "s" : "",
            brokenLinkCount, brokenLinkCount != 1 ? "s" : "");
    }
    // Check if we have re-link pin
    for (auto pair : relink_pairs)
    {
        pair.first->LinkTo(*pair.second);
        if (m_CallBacks.BluePrintOnChanged)
        {
            auto ret = m_CallBacks.BluePrintOnChanged(BP_CB_Link, m_Document->m_Name, m_UserHandle);
        }
    }
    // discard this OpRecord if nothing is actually deleted
    if (validDeletion)
        BeginOpRecord("DestroyAction");
}

void BluePrintUI::HandleContextMenuAction(uint32_t flag)
{
    if (!m_Document)
        return;
    
    if (m_Document->m_Blueprint.IsExecuting() && !m_Document->m_Blueprint.IsPaused())
        return;

    if (ed::ShowBackgroundContextMenu())
    {
        ed::Suspend();
        LOGI("[HandleContextMenuAction] Show Background Context Menu");
        if ((flag & BluePrintFlag::BluePrintFlag_All) != 0)
        {
            m_ContextMenu.Open();
        }
        else
        {
            CleanStateStorage();
            if ((flag & BluePrintFlag::BluePrintFlag_Filter) != 0)
            {
                ImGui::OpenPopup("##create_filter_node");
            }
            else if ((flag & BluePrintFlag::BluePrintFlag_Transition) != 0)
            {
                ImGui::OpenPopup("##create_transition_node");
            }
            else if ((flag & BluePrintFlag::BluePrintFlag_System) != 0)
            {
                ImGui::OpenPopup("##create_system_node");
            }
        }
        ed::Resume();
    }

    if ((flag & BluePrintFlag::BluePrintFlag_All) != 0)
    {
        ed::NodeId contextNodeId;
        if (ed::ShowNodeContextMenu(&contextNodeId))
        {
            auto node = m_Document->m_Blueprint.FindNode(static_cast<uint32_t>(contextNodeId.Get()));

            ed::Suspend();
            LOGI("[HandleContextMenuAction] Open NodeContextMenu for %" PRI_node, FMT_node(node));
            m_NodeContextMenu.Open(node);
            ed::Resume();
        }
    }

    ed::PinId contextPinId;
    if (ed::ShowPinContextMenu(&contextPinId))
    {
        auto pin = m_Document->m_Blueprint.FindPin(static_cast<uint32_t>(contextPinId.Get()));

        ed::Suspend();
        LOGI("[HandleContextMenuAction] Open PinContextMenu for %" PRI_pin, FMT_pin(pin));
        m_PinContextMenu.Open(pin);
        ed::Resume();
    }

    ed::LinkId contextLinkId;
    if (ed::ShowLinkContextMenu(&contextLinkId))
    {
        auto pin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(contextLinkId.Get()));

        ed::Suspend();
        LOGI("[HandleContextMenuAction] Open LinkContextMenu for %" PRI_pin, FMT_pin(pin));
        m_LinkContextMenu.Open(pin);
        ed::Resume();
    }
}

bool BluePrintUI::File_IsOpen()
{
    return m_Document != nullptr;
}

bool BluePrintUI::File_IsModified()
{
    return m_Document->m_IsModified;
}

void BluePrintUI::File_MarkModified()
{
    ed::Update();
    if (m_Document->m_IsModified)
        return;
    m_Document->m_IsModified = true;
}

Node* BluePrintUI::FindEntryPointNode()
{
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        if (node->GetTypeInfo().m_Type == NodeType::EntryPoint)
        {
            return node;
        }
    }

    return nullptr;
}

Node* BluePrintUI::FindExitPointNode()
{
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        if (node->GetTypeInfo().m_Type == NodeType::ExitPoint)
        {
            return node;
        }
    }

    return nullptr;
}

void BluePrintUI::CleanStateStorage()
{
    auto window = ImGui::GetCurrentWindowRead();
    if (window)
    {
        auto current_window = (*GImGui).CurrentWindow;
        auto storage = ImGui::GetStateStorage();
        if (storage && current_window)
        {
            storage->SetVoidPtr(current_window->GetID("##node-context-menu-node"), nullptr);
            storage->SetVoidPtr(current_window->GetID("##pin-context-menu-pin"), nullptr);
            storage->SetVoidPtr(current_window->GetID("##link-context-menu-pin"), nullptr);
            storage->SetVoidPtr(current_window->GetID("##setting-node"), nullptr);
            storage->SetVoidPtr(current_window->GetID("##delete-node"), nullptr);
            storage->SetVoidPtr(current_window->GetID("##create_node_pin"), nullptr);
        }
    }
}

bool BluePrintUI::Blueprint_IsValid()
{
    if (!m_Document)
        return false;
    if (!m_Document->m_Blueprint.IsOpened())
        return false;
    auto entryNode = FindEntryPointNode();
    auto exitNode = FindExitPointNode();
    if (!entryNode || !exitNode)
        return false;
    if (!entryNode->m_ID || !exitNode->m_ID)
        return false;
    return true;
}

bool BluePrintUI::Blueprint_IsExecutable()
{
    if (!Blueprint_IsValid())
        return false;

    auto entryNode = FindEntryPointNode();
    auto exitNode = FindExitPointNode();

    bool linked = false;
    // first check entry node links
    auto entry_flow = entryNode->GetAutoLinkOutputFlowPin();
    if (!entry_flow) return false;
    if (!entry_flow->IsLinked()) return false;
    auto entry_data = entryNode->GetAutoLinkOutputDataPin();
    if (entry_data.empty()) return false;
    for (auto entry_data_pin : entry_data)
    {
        if (entry_data_pin->IsLinked()) linked = true;
    }
    if (!linked) return false;

    // then we check exit node links
    linked = false;
    auto exit_flow = exitNode->GetAutoLinkInputFlowPin();
    if (!exit_flow) return false;
    if (!exit_flow->IsLinked()) return false;
    auto exit_data = exitNode->GetAutoLinkInputDataPin();
    if (exit_data.empty()) return false;
    for (auto exit_data_pin : exit_data)
    {
        if (exit_data_pin->IsLinked()) linked = true;
    }
    if (!linked) return false;

    return true;
}

bool BluePrintUI::Blueprint_IsEmpty()
{
    if (!Blueprint_IsValid())
        return true;
    if (m_Document->m_Blueprint.GetNodes().size() <= 2)
        return true;
    return false;
}

bool BluePrintUI::File_Open(std::string path, string* error)
{
    if (File_IsOpen())
    {
        m_Document->Save();
        ed::ClearSelection();
        m_Document->m_Blueprint.Clear();
    }
    if (m_Document->Load(path) != BP_ERR_NONE)
    {
        if (error)
        {
            ImGuiTextBuffer buffer;
            buffer.appendf("Failed to load blueprint from file \"%" PRI_sv "\".", FMT_sv(path));
            *error = buffer.c_str();
        }
        else
            LOGE("Failed to load blueprint from file \"%" PRI_sv "\".", FMT_sv(path));
        return false;
    }

    LOGI("[File] Open \"%" PRI_sv "\"", FMT_sv(path));
    if (!m_isChildWindow)
    {
        auto mostRecentlyOpenFiles = ImGui::MostRecentlyUsedList("BluePrintOpenList");
        mostRecentlyOpenFiles.Add(path);
        m_Document->SetPath(path);
    }
    m_Document->OnMakeCurrent();
    if (m_DebugOverlay) m_DebugOverlay->Init(&m_Document->m_Blueprint);
    return true;
}

bool BluePrintUI::File_Open()
{
    bool result = true;
    IGFD::FileDialogConfig config;
    config.path = ".";
	config.countSelectionMax = 1;
    config.flags = ImGuiFileDialogFlags_OpenFile_Default;
    if (m_BookMarkPath.empty()) config.flags &= ~ImGuiFileDialogFlags_ShowBookmark;
    const char *filters = "Blue print file (*.json *.bp){.json,.bp},.*";
    ImGuiFileDialog::Instance()->OpenDialog("##BlueprintUI##OpenFileDlgKey", ICON_IGFD_FOLDER_OPEN " Open File", filters, config);
    return result;
}

bool BluePrintUI::File_Import(std::string path, ImVec2 pos, string* error)
{
    if (m_Document->Import(path, pos) != BP_ERR_NONE)
    {
        if (error)
        {
            ImGuiTextBuffer buffer;
            buffer.appendf("Failed to import group from file \"%" PRI_sv "\".", FMT_sv(path));
            *error = buffer.c_str();
        }
        else
            LOGE("Failed to import group from file \"%" PRI_sv "\".", FMT_sv(path));
        return false;
    }

    LOGI("[File] Import group\"%" PRI_sv "\"", FMT_sv(path));
    return true;
}

bool BluePrintUI::File_Import()
{
    bool result = true;
    IGFD::FileDialogConfig config;
    config.path = ".";
    config.countSelectionMax = 1;
    config.userDatas = &m_PopupMousePos;
    config.flags = ImGuiFileDialogFlags_OpenFile_Default;
    if (m_BookMarkPath.empty()) config.flags &= ~ImGuiFileDialogFlags_ShowBookmark;
    const char *filters = "Group file (*.group *.gp){.group,.gp},.*";
    ImGuiFileDialog::Instance()->OpenDialog("##BlueprintUI##ImportGroupDlgKey", ICON_IGFD_FOLDER_OPEN " Open File", filters, config);
    return result;
}

bool BluePrintUI::File_New()
{
    File_Close();
    ed::SetCurrentEditor(m_Editor);
    ed::ClearSelection();
    m_Document->m_Blueprint.Clear();
    CleanStateStorage();
    ed::NavigateToOrigin();
    CreateNewDocument();
    m_Document->m_Path = "";
    m_Document->m_Name = "NONAMED";
    m_Document->m_IsModified = true;
    if (m_DebugOverlay) m_DebugOverlay->Init(&m_Document->m_Blueprint);
    //ed::SetCurrentEditor(nullptr);
    return true;
}

bool BluePrintUI::File_New_Filter(imgui_json::value& bp, std::string name, std::string sfilter)
{
    ed::SetCurrentEditor(m_Editor);
    ed::ClearSelection();
    m_Document->m_Blueprint.Clear();
    CleanStateStorage();
    if (bp.is_object())
    {
        if (m_Document->Deserialize(bp, *m_Document) != BP_ERR_NONE || m_Document->m_Blueprint.GetNodes().size() == 0)
        {
            // TODO::Dicky if node load failed, may not CreateNewDocument
            CreateNewFilterDocument();
            m_Document->OnMakeCurrent();
            bp = m_Document->Serialize();
        }
        else
        {
            m_Document->OnMakeCurrent();
        }
    }
    else
    {
        CreateNewFilterDocument();
        m_Document->OnMakeCurrent();
        bp = m_Document->Serialize();
    }
    if (name.empty())
        m_Document->m_Name = "FilterBluePrint";
    else
        m_Document->m_Name = name;
    if (sfilter.empty())
        m_Document->m_CatalogFilter = "";
    else
        m_Document->m_CatalogFilter = sfilter;

    if (m_DebugOverlay) m_DebugOverlay->Init(&m_Document->m_Blueprint);
    //ed::SetCurrentEditor(nullptr);
    return true;
}

bool BluePrintUI::File_New_Transition(imgui_json::value& bp, std::string name, std::string sfilter)
{
    ed::SetCurrentEditor(m_Editor);
    ed::ClearSelection();
    m_Document->m_Blueprint.Clear();
    CleanStateStorage();
    if (bp.is_object())
    {
        if (m_Document->Deserialize(bp, *m_Document) != BP_ERR_NONE || m_Document->m_Blueprint.GetNodes().size() == 0)
        {
            // TODO::Dicky if node load failed, may not CreateNewDocument
            CreateNewTransitionDocument();
            m_Document->OnMakeCurrent();
            bp = m_Document->Serialize();
        }
        else
        {
            m_Document->OnMakeCurrent();
        }
    }
    else
    {
        CreateNewTransitionDocument();
        m_Document->OnMakeCurrent();
        bp = m_Document->Serialize();
    }
    if (name.empty())
        m_Document->m_Name = "TransitionBluePrint";
    else
        m_Document->m_Name = name;

    if (sfilter.empty())
        m_Document->m_CatalogFilter = "";
    else
        m_Document->m_CatalogFilter = sfilter;
    
    if (m_DebugOverlay) m_DebugOverlay->Init(&m_Document->m_Blueprint);
    //ed::SetCurrentEditor(nullptr);
    return true;
}

bool BluePrintUI::File_SaveAsEx(std::string path)
{
    if (!File_IsOpen())
        return true;
    if (!m_Document->Save(path))
    {
        LOGE("Failed to save blueprint to file \"%" PRI_sv "\".", FMT_sv(path));
        return false;
    }
    m_Document->m_IsModified = false;
    LOGI("[File] Save \"%" PRI_sv "\".", FMT_sv(path));
    return true;
}

bool BluePrintUI::File_SaveAs()
{
    const char *filters = "Blue print file (*.json *.bp){.json,.bp},.*";
    IGFD::FileDialogConfig config;
    config.path = ".";
    config.countSelectionMax = 1;
    config.flags = ImGuiFileDialogFlags_SaveFile_Default;
    if (m_BookMarkPath.empty()) config.flags &= ~ImGuiFileDialogFlags_ShowBookmark;
    ImGuiFileDialog::Instance()->OpenDialog("##BlueprintUI##SaveFileDlgKey", ICON_IGFD_FOLDER_OPEN " Save File", filters, config);
    return true;
}

bool BluePrintUI::File_Save()
{
    if (!m_Document->m_Path.empty())
        return File_SaveAsEx(m_Document->m_Path);
    else
        return File_SaveAs();
}

bool BluePrintUI::File_Close()
{
    // TODO::Dicky Do we need close file?
    if (!File_IsOpen())
        return true;
    bool result = true;
    if (File_IsModified())
    {
        File_Save();
    }
    LOGI("[File] Close");
    return result;
}

bool BluePrintUI::File_Exit()
{
    // TODO::Dicky Do we need Exit
    LOGI("Quit");
    ReadyToQuit = true;
    return false;
}

bool BluePrintUI::Edit_Undo()
{
    bool ret = false;
    if (m_Document)
    {
        ret = m_Document->Undo();
        if (m_DebugOverlay) m_DebugOverlay->Init(&m_Document->m_Blueprint);
    }
    return ret;
}

bool BluePrintUI::Edit_Redo()
{
    return m_Document ? m_Document->Redo() : false;
}

bool BluePrintUI::Edit_Cut()
{
    m_ClipBoard.clear();
    auto selectedNodes = GetSelectedNodes(&m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto node : selectedNodes)
    {
        auto clip = ClipNode(node);
        m_ClipBoard.push_back(clip);
        LOGI("[Edit]: Cut Node %s", clip.m_Name.c_str());
        ed::DeleteNode(node->m_ID);
    }
    File_MarkModified();
    return selectedNodes.size() > 0;
}

bool BluePrintUI::Edit_Copy()
{
    m_ClipBoard.clear();
    auto nodes = GetSelectedNodes(&m_Document->m_Blueprint);
    for (auto node : nodes)
    {
        auto clip = ClipNode(node);
        m_ClipBoard.push_back(clip);
        LOGI("[Edit]: Copy Node %s", node->GetName().c_str());
    }
    return nodes.size();
}

bool BluePrintUI::Edit_Paste()
{
    ed::ClearSelection();
    for (auto clip : m_ClipBoard)
    {
        auto clone_node = m_Document->m_Blueprint.CreateNode(clip.m_NodeInfo.m_ID);
        
        ed::SetNodePosition(clone_node->m_ID, ImVec2(clip.m_Pos.x + 40, clip.m_Pos.y + 80));
        ed::SetNodeSize(clone_node->m_ID, clip.m_Size);
        ed::SetGroupSize(clone_node->m_ID, clip.m_GroupSize);
        ed::SelectNode(clone_node->m_ID, true);
        clone_node->SetName(clip.m_Name);
        LOGI("[Edit]: Paste Node %s", clip.m_Name.c_str());
    }
    return m_ClipBoard.size() > 0;
}

bool BluePrintUI::Edit_Duplicate()
{
    auto nodes = GetSelectedNodes(&m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto node : nodes)
    {
        auto nodeStart = ed::GetNodePosition(node->m_ID);
        auto nodeSize = ed::GetNodeSize(node->m_ID);
        auto groupSize = ed::GetGroupSize(node->m_ID);
        auto clone_node = m_Document->m_Blueprint.CloneNode(node);
        if (!clone_node)
            continue;
        ed::SetNodePosition(clone_node->m_ID, ImVec2(nodeStart.x + 40, nodeStart.y + 80));
        ed::SetNodeSize(clone_node->m_ID, nodeSize);
        ed::SetGroupSize(clone_node->m_ID, groupSize);
        ed::SelectNode(clone_node->m_ID, true);
        LOGI("[Edit]: Clone Node 0x%08" PRIX32, clone_node->m_ID);
    }
    return nodes.size() > 0;
}

bool BluePrintUI::Edit_Delete()
{
    auto selectedNodes = GetSelectedNodes(&m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto node : selectedNodes)
    {
        ed::DeleteNode(node->m_ID);
        LOGI("[Edit]: Delete Node 0x%08" PRIX32, node->m_ID);
    }
    File_MarkModified();
    return selectedNodes.size() > 0;
}

bool BluePrintUI::Edit_Unlink()
{
    auto selectedLinks = GetSelectedLinks(&m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto selectedLink : selectedLinks)
    {
        ed::DeleteLink(selectedLink->m_ID);
        LOGI("[Edit]: Remove Link 0x%08" PRIX32, selectedLink->m_ID);
    }
    File_MarkModified();
    return selectedLinks.size() > 0;
}

bool BluePrintUI::Edit_Setting()
{
    return false; // TODO::Dicky add BluePrintUI Edit_Setting
}

bool BluePrintUI::Edit_Insert(ID_TYPE id)
{
    if (!Blueprint_IsValid())
        return false;
    ed::SetCurrentEditor(m_Editor);
    ed::ClearSelection();
    auto new_node = m_Document->m_Blueprint.CreateNode(id);
    if (!new_node)
    {
        return false;
    }

    ImVec2 node_pos = ImVec2(40, 80);
    auto ret = m_CallBacks.BluePrintOnChanged(BP_CB_NODE_INSERT, m_Document->m_Name, m_UserHandle);
    if (ret == BP_CBR_AutoLink)
    {
        auto hoveredNode = m_Document->m_Blueprint.FindNode(static_cast<ID_TYPE>(ed::GetHoveredNode().Get()));
        auto hoveredPin  = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(ed::GetHoveredPin().Get()));
        auto hoveredLink = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(ed::GetHoveredLink().Get()));
        Node* input_node = nullptr;
        Node* output_node = nullptr;
        if (hoveredNode)
        {
            input_node = hoveredNode;
            auto fromPin = input_node->GetAutoLinkOutputFlowPin();
            if (fromPin)
            {
                Pin* linked_pin = fromPin->GetLink(&m_Document->m_Blueprint);
                if (linked_pin) output_node = linked_pin->m_Node;
            }
        }
        else if (hoveredPin || hoveredLink)
        {
            auto fromPin = hoveredPin ? hoveredPin : hoveredLink;
            input_node = fromPin->m_Node;
            if (fromPin->GetType() == PinType::Flow)
            {
                Pin* linked_pin = fromPin->GetLink(&m_Document->m_Blueprint);
                if (linked_pin) output_node = linked_pin->m_Node;
            }
            else if (!fromPin->m_LinkFrom.empty())
            {
                Pin* linked_pin = m_Document->m_Blueprint.GetPinFromID(fromPin->m_LinkFrom[0]);
                if (linked_pin) output_node = linked_pin->m_Node;
            }
            else if (fromPin->m_Link)
            {
                output_node = fromPin->m_Node;
                Pin* linked_pin = m_Document->m_Blueprint.GetPinFromID(fromPin->m_Link);
                if (linked_pin) input_node = linked_pin->m_Node;
            }

        }
        HandleAutoLink(new_node, input_node, output_node);
        if (input_node)
        {
            auto _pos = ed::GetNodePosition(input_node->m_ID);
            auto _size = Blueprint_EstimateNodeSize(input_node);
            _size.x = _size.x > 0 ? _size.x : 350;
            node_pos.x = _pos.x + _size.x + 100;
            node_pos.y = _pos.y + 50;
        }
    }

    ed::SetNodePosition(new_node->m_ID, node_pos);
    ed::SelectNode(new_node->m_ID, true);
    return true;
}

bool BluePrintUI::View_ShowFlow()
{
    if (!m_Document)
        return false;

    m_Document->m_Blueprint.ShowFlow();
    
    return true;
}

bool BluePrintUI::View_ShowMeters()
{
    if (!m_Document)
        return false;

    ed::TriggerShowMeters();
    return true;
}

bool BluePrintUI::View_ZoomToContent()
{
    if (m_Document)
    {
        ed::NavigateToContent();
        return true;
    }
    return false;
}

bool BluePrintUI::View_ZoomToSelection()
{
    if (m_Document)
    {
        ed::NavigateToSelection(true);
        return true;
    }
    return false;
}

bool BluePrintUI::View_NavigateBackward()
{
    return false; // TODO::Dicky add BluePrintUI View_NavigateBackward
}

bool BluePrintUI::View_NavigateForward()
{
    return false; // TODO::Dicky add BluePrintUI View_NavigateForward
}

bool BluePrintUI::Blueprint_Stop()
{
    if (!m_Document)
        return false;
    m_Document->m_Blueprint.Stop();
    return true;
}

bool BluePrintUI::Blueprint_Run()
{
    if (!m_Document)
        return false;
    auto entryNode = FindEntryPointNode();
    auto result = m_Document->m_Blueprint.Execute(*entryNode);
    if (result == StepResult::Error)
    {
        LOGI("Execution: Failed at step %" PRIu32, m_Document->m_Blueprint.StepCount());
        return false;
    }
    else if (result == StepResult::Done)
    {
        LOGI("Execution: Running");
    }
    return true;
}

bool BluePrintUI::Blueprint_SetFilter(const std::string name, const PinValue& value)
{
    if (!Blueprint_IsValid())
        return false;
    auto entry_node = FindEntryPointNode();
    if (!entry_node)
        return false;
    FilterEntryPointNode * entryNode = (FilterEntryPointNode *)entry_node;
    FloatPin * pin = (FloatPin * )entryNode->FindPin(name);
    if (pin)
    {
        return pin->SetValue(value);
    }
    return false;
}

bool BluePrintUI::Blueprint_RunFilter(ImGui::ImMat& input, ImGui::ImMat& output, int64_t current, int64_t duration, bool bypass_bg_node)
{
    if (!Blueprint_IsValid())
        return false;
    auto entry_node = FindEntryPointNode();
    auto exit_node = FindExitPointNode();
    if (!entry_node || !exit_node)
        return false;
    
    m_Document->m_Blueprint.SetTimeStamp(current);
    m_Document->m_Blueprint.SetDurtion(duration);
    FilterEntryPointNode * entryNode = (FilterEntryPointNode *)entry_node;
    MatExitPointNode * exitNode = (MatExitPointNode *)exit_node;
    entryNode->m_MatOut.SetValue(input);
    auto result = m_Document->m_Blueprint.Run(*entryNode, bypass_bg_node);
    if (result == StepResult::Error)
    {
        LOGI("Execution: Failed at step %" PRIu32, m_Document->m_Blueprint.StepCount());
        return false;
    }
    else if (result == StepResult::Done)
    {
        LOGI("Execution: Running");
    }
    auto output_val = exitNode->m_MatIn.GetValue();
    output = output_val.As<ImGui::ImMat>();
    return true;
}

bool BluePrintUI::Blueprint_SetTransition(const std::string name, const PinValue& value)
{
    if (!Blueprint_IsValid())
        return false;
    auto entry_node = FindEntryPointNode();
    if (!entry_node)
        return false;
    TransitionEntryPointNode * entryNode = (TransitionEntryPointNode *)entry_node;
    FloatPin * pin = (FloatPin * )entryNode->FindPin(name);
    if (pin)
    {
        return pin->SetValue(value);
    }
    return false;
}

bool BluePrintUI::Blueprint_RunTransition(ImGui::ImMat& input_first, ImGui::ImMat& input_second, ImGui::ImMat& output, int64_t current, int64_t duration, bool bypass_bg_node)
{
    if (!Blueprint_IsValid())
        return false;
    auto entry_node = FindEntryPointNode();
    auto exit_node = FindExitPointNode();
    if (!entry_node || !exit_node)
        return false;
    
    m_Document->m_Blueprint.SetTimeStamp(current);
    m_Document->m_Blueprint.SetDurtion(duration);
    TransitionEntryPointNode * entryNode = (TransitionEntryPointNode *)entry_node;
    MatExitPointNode * exitNode = (MatExitPointNode *)exit_node;
    float progress = (float)current / (float)duration;
    entryNode->m_MatOutFirst.SetValue(input_first);
    entryNode->m_MatOutSecond.SetValue(input_second);
    entryNode->m_TransitionPos.SetValue(progress);
    auto result = m_Document->m_Blueprint.Run(*entryNode, bypass_bg_node);
    if (result == StepResult::Error)
    {
        LOGI("Execution: Failed at step %" PRIu32, m_Document->m_Blueprint.StepCount());
        return false;
    }
    else if (result == StepResult::Done)
    {
        LOGI("Execution: Running");
    }
    auto output_val = exitNode->m_MatIn.GetValue();
    output = output_val.As<ImGui::ImMat>();
    return true;
}

bool BluePrintUI::Blueprint_Pause()
{
    if (!m_Document)
        return false;
    auto result = m_Document->m_Blueprint.Pause();
    LOGI("Execution: Paused at step %" PRIu32, m_Document->m_Blueprint.StepCount());
    return true;
}

bool BluePrintUI::Blueprint_Next()
{
    if (!m_Document)
        return false;
    auto result = m_Document->m_Blueprint.Next();

    ed::PushStyleVar(ed::StyleVar_FlowMarkerDistance, 30.0f);
    ed::PushStyleVar(ed::StyleVar_FlowDuration, 1.0f);
    m_Document->m_Blueprint.ShowFlow();
    ed::PopStyleVar(2);

    return true;
}

bool BluePrintUI::Blueprint_Current()
{
    if (!m_Document)
        return false;
    auto result = m_Document->m_Blueprint.Current();

    ed::PushStyleVar(ed::StyleVar_FlowMarkerDistance, 30.0f);
    ed::PushStyleVar(ed::StyleVar_FlowDuration, 1.0f);
    m_Document->m_Blueprint.ShowFlow();
    ed::PopStyleVar(2);

    return true;
}

bool BluePrintUI::Blueprint_StepToEnd(Node* node)
{
    if (!m_Document || !node)
        return false;
    auto result = m_Document->m_Blueprint.StepToEnd(node);
    return true;
}

bool BluePrintUI::Blueprint_BreakPoint()
{
    if (!m_Document)
        return false;
    auto selectedNodes = GetSelectedNodes(&m_Document->m_Blueprint);
    for (auto node : selectedNodes)
    {
        if (node->m_BreakPoint)
        {
            node->SetBreakPoint(false);
            LOGI("Execution: delete breakpoint 0x%08" PRIX32, node->m_ID);
        }
        else
        {
            node->SetBreakPoint(true);
            LOGI("Execution: Set breakpoint 0x%08" PRIX32, node->m_ID);
        }
    }
    return true;
}

bool BluePrintUI::Blueprint_AppendNode(ID_TYPE type_id, ID_TYPE* node_id)
{
    if (!m_Document)
        return false;
    if (!Blueprint_IsValid())
        return false;
    ed::SetCurrentEditor(m_Editor);
    auto new_node = m_Document->m_Blueprint.CreateNode(type_id);
    if (!new_node)
    {
        //ed::SetCurrentEditor(nullptr);
        return false;
    }
    new_node->PreLoad();
    BeginOpRecord("AppendNode");

    if (node_id) *node_id = new_node->m_ID;
    auto exitNode = FindExitPointNode(); // must be existed, check by Blueprint_IsValid()
    BluePrint::Node* last_linked_node = nullptr;
    auto exit_flow_pin = exitNode->GetAutoLinkInputFlowPin();
    auto exit_data_pin = exitNode->GetAutoLinkInputDataPin();
    auto new_flow_in_pin = new_node->GetAutoLinkInputFlowPin();
    auto new_data_in_pin = new_node->GetAutoLinkInputDataPin();
    auto new_flow_out_pin = new_node->GetAutoLinkOutputFlowPin();
    auto new_data_out_pin = new_node->GetAutoLinkOutputDataPin();
    if (exit_flow_pin && exit_flow_pin->m_LinkFrom.size() > 0)
    {
        for (auto link_id : exit_flow_pin->m_LinkFrom)
        {
            auto link_pin = m_Document->m_Blueprint.GetPinFromID(link_id);
            if (link_pin)
            {
                // re-link prev node flow to new_node
                if (new_flow_in_pin)
                {
                    link_pin->LinkTo(*new_flow_in_pin);
                }
                if (!last_linked_node)
                {
                    last_linked_node = link_pin->m_Node;
                }
            }
        }
        // re-link new node flow to exitPoint node
        if (new_flow_out_pin)
        {
            new_flow_out_pin->LinkTo(*exit_flow_pin);
        }
    }
    if (exit_data_pin.size() > 0 && new_data_out_pin.size() > 0 && exit_data_pin.size() == new_data_out_pin.size())
    {
        for (int i = 0; i < exit_data_pin.size(); i++)
        {
            auto in_pin = exit_data_pin[i];
            auto out_pin = new_data_out_pin[i];
            // unlink current data
            auto linked_pin = m_Document->m_Blueprint.GetPinFromID(in_pin->m_Link);
            if (linked_pin)
                ed::DeleteLink(linked_pin->m_ID);
            // re-link new_node data to exitPoint node
            in_pin->LinkTo(*out_pin);
            if (linked_pin && new_data_in_pin.size() > 0)
            {
                // re-link prev data to new node data pin
                new_data_in_pin[0]->LinkTo(*linked_pin);
            }
            if (!last_linked_node && linked_pin)
            {
                last_linked_node = linked_pin->m_Node;
            }
        }
    }

    auto exit_node_pos = ed::GetNodePosition(exitNode->m_ID);
    auto new_node_pos = exit_node_pos;
    if (last_linked_node)
    {
        auto _pos = ed::GetNodePosition(last_linked_node->m_ID);
        auto _size = Blueprint_EstimateNodeSize(last_linked_node);
        _size.x = _size.x > 0 ? _size.x : 350;
        auto _current_size = Blueprint_EstimateNodeSize(new_node);
        _current_size.x = _current_size.x > 0 ? _current_size.x + 50 : 400;
        float space = exit_node_pos.x - (_pos.x + _size.x);

        if (space < _current_size.x)
        {
            exit_node_pos.x = _pos.x + _size.x + _current_size.x;
            ed::SetNodePosition(exitNode->m_ID, exit_node_pos);
        }
        new_node_pos.x = _pos.x + _size.x + 50;
    }
    else
    {
        new_node_pos.x = exit_node_pos.x - 350;
    }

    ed::SetNodePosition(new_node->m_ID, new_node_pos);

    if (m_CallBacks.BluePrintOnChanged)
    {
        m_CallBacks.BluePrintOnChanged(BP_CB_NODE_APPEND, m_Document->m_Name, m_UserHandle);
    }
    File_MarkModified();
    //ed::SetCurrentEditor(nullptr);
    EndOpRecord();
    return true;
}

bool BluePrintUI::Blueprint_SwapNode(ID_TYPE src_id, ID_TYPE dst_id)
{
    ed::SetCurrentEditor(m_Editor);
    auto src = m_Document->m_Blueprint.FindNode(src_id);
    auto dst = m_Document->m_Blueprint.FindNode(dst_id);
    if (!src || !dst)
    {
        //ed::SetCurrentEditor(nullptr);
        return false;
    }
    BeginOpRecord("SwapNode");

    auto src_pos = ed::GetNodePosition(src->m_ID);
    auto dst_pos = ed::GetNodePosition(dst->m_ID);
    vector<std::pair<Pin *, Pin *>> relink_pairs;

    auto src_flow_in_pin = src->GetAutoLinkInputFlowPin();
    auto dst_flow_in_pin = dst->GetAutoLinkInputFlowPin();
    auto src_flow_out_pin = src->GetAutoLinkOutputFlowPin();
    auto dst_flow_out_pin = dst->GetAutoLinkOutputFlowPin();

    auto src_data_in_pin = src->GetAutoLinkInputDataPin();
    auto dst_data_in_pin = dst->GetAutoLinkInputDataPin();
    auto src_data_out_pin = src->GetAutoLinkOutputDataPin();
    auto dst_data_out_pin = dst->GetAutoLinkOutputDataPin();

    bool is_connected = false;
    int connect_direction = -1;
    if (src_flow_out_pin && dst_flow_in_pin && src_flow_out_pin->m_Link == dst_flow_in_pin->m_ID)
    {
        is_connected = true;
        connect_direction = 0; // src -> dst
    }
    if (dst_flow_out_pin && src_flow_in_pin && dst_flow_out_pin->m_Link == src_flow_in_pin->m_ID)
    {
        is_connected = true; 
        connect_direction = 1; // dst -> src
    }
    if (is_connected)
    {
        if (connect_direction == 0)
        {
            // src -> dst
            // link dst out flow into src
            std::pair<Pin *, Pin *> re_link(dst_flow_out_pin, src_flow_in_pin);
            relink_pairs.push_back(re_link);
            // link src out flow into dst out links
            auto dst_flow_out_link_pin = m_Document->m_Blueprint.GetPinFromID(dst_flow_out_pin->m_Link);
            std::pair<Pin *, Pin *> re_link_out(src_flow_out_pin, dst_flow_out_link_pin);
            relink_pairs.push_back(re_link_out);
            // link src input flow to dst input flow
            for (auto from_pin : src_flow_in_pin->m_LinkFrom)
            {
                auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
                std::pair<Pin *, Pin *> re_link_in(pin, dst_flow_in_pin);
                relink_pairs.push_back(re_link_in);
            }

            // link dst out data into src
            for (int i = 0; i < dst_data_out_pin.size(); i++)
            {
                if (i < src_data_in_pin.size())
                {
                    std::pair<Pin *, Pin *> re_link_data(src_data_in_pin[i], dst_data_out_pin[i]);
                    relink_pairs.push_back(re_link_data);
                }
            }

            // link src out data into dst out data links
            for (int i = 0; i < src_data_out_pin.size(); i++)
            {
                if (i < dst_data_out_pin.size())
                {
                    for (auto from_pin : dst_data_out_pin[i]->m_LinkFrom)
                    {
                        auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
                        std::pair<Pin *, Pin *> re_link_in(pin, src_data_out_pin[i]);
                        relink_pairs.push_back(re_link_in);
                    }
                }
            }

            // link src input data to dst input data
            for (int i = 0; i < src_data_in_pin.size(); i++)
            {
                if (i < dst_data_in_pin.size())
                {
                    auto src_data_in_link_pin = m_Document->m_Blueprint.GetPinFromID(src_data_in_pin[i]->m_Link);
                    std::pair<Pin *, Pin *> re_link_in(dst_data_in_pin[i], src_data_in_link_pin);
                    relink_pairs.push_back(re_link_in);
                }
            }
        }
        else
        {
            // dst -> src
            // link src out flow into dst
            std::pair<Pin *, Pin *> re_link(src_flow_out_pin, dst_flow_in_pin);
            relink_pairs.push_back(re_link);
            // link dst out flow into src out links
            auto src_flow_out_link_pin = m_Document->m_Blueprint.GetPinFromID(src_flow_out_pin->m_Link);
            std::pair<Pin *, Pin *> re_link_out(dst_flow_out_pin, src_flow_out_link_pin);
            relink_pairs.push_back(re_link_out);
            // link dst input flow to src input flow
            for (auto from_pin : dst_flow_in_pin->m_LinkFrom)
            {
                auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
                std::pair<Pin *, Pin *> re_link_in(pin, src_flow_in_pin);
                relink_pairs.push_back(re_link_in);
            }

            // link src out data into dst
            for (int i = 0; i < src_data_out_pin.size(); i++)
            {
                if (i < dst_data_in_pin.size())
                {
                    std::pair<Pin *, Pin *> re_link_data(dst_data_in_pin[i], src_data_out_pin[i]);
                    relink_pairs.push_back(re_link_data);
                }
            }

            // link dst out data into src out data links
            for (int i = 0; i < dst_data_out_pin.size(); i++)
            {
                if (i < src_data_out_pin.size())
                {
                    for (auto from_pin : src_data_out_pin[i]->m_LinkFrom)
                    {
                        auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
                        std::pair<Pin *, Pin *> re_link_in(pin, dst_data_out_pin[i]);
                        relink_pairs.push_back(re_link_in);
                    }
                }
            }

            // link dst input data to src input data
            for (int i = 0; i < dst_data_in_pin.size(); i++)
            {
                if (i < src_data_in_pin.size())
                {
                    auto dst_data_in_link_pin = m_Document->m_Blueprint.GetPinFromID(dst_data_in_pin[i]->m_Link);
                    std::pair<Pin *, Pin *> re_link_in(src_data_in_pin[i], dst_data_in_link_pin);
                    relink_pairs.push_back(re_link_in);
                }
            }
        }
    }
    else
    {
        // link src out flow into dst out link
        auto dst_flow_out_link_pin = m_Document->m_Blueprint.GetPinFromID(dst_flow_out_pin->m_Link);
        std::pair<Pin *, Pin *> re_link_src(src_flow_out_pin, dst_flow_out_link_pin);
        relink_pairs.push_back(re_link_src);
        // link dst out flow into src out link
        auto src_flow_out_link_pin = m_Document->m_Blueprint.GetPinFromID(src_flow_out_pin->m_Link);
        std::pair<Pin *, Pin *> re_link_dst(dst_flow_out_pin, src_flow_out_link_pin);
        relink_pairs.push_back(re_link_dst);
        // link src input flow to dst input flow
        for (auto from_pin : src_flow_in_pin->m_LinkFrom)
        {
            auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
            std::pair<Pin *, Pin *> re_link_in(pin, dst_flow_in_pin);
            relink_pairs.push_back(re_link_in);
        }
        // link dst input flow to src input flow
        for (auto from_pin : dst_flow_in_pin->m_LinkFrom)
        {
            auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
            std::pair<Pin *, Pin *> re_link_in(pin, src_flow_in_pin);
            relink_pairs.push_back(re_link_in);
        }

        // link src out data into dst out data links
        for (int i = 0; i < src_data_out_pin.size(); i++)
        {
            if (i < dst_data_out_pin.size())
            {
                for (auto from_pin : dst_data_out_pin[i]->m_LinkFrom)
                {
                    auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
                    std::pair<Pin *, Pin *> re_link_in(pin, src_data_out_pin[i]);
                    relink_pairs.push_back(re_link_in);
                }
            }
        }

        // link dst out data into src out data links
        for (int i = 0; i < dst_data_out_pin.size(); i++)
        {
            if (i < src_data_out_pin.size())
            {
                for (auto from_pin : src_data_out_pin[i]->m_LinkFrom)
                {
                    auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
                    std::pair<Pin *, Pin *> re_link_in(pin, dst_data_out_pin[i]);
                    relink_pairs.push_back(re_link_in);
                }
            }
        }

        // link src input data to dst input data
        for (int i = 0; i < src_data_in_pin.size(); i++)
        {
            if (i < dst_data_in_pin.size())
            {
                auto src_data_in_link_pin = m_Document->m_Blueprint.GetPinFromID(src_data_in_pin[i]->m_Link);
                std::pair<Pin *, Pin *> re_link_in(dst_data_in_pin[i], src_data_in_link_pin);
                relink_pairs.push_back(re_link_in);
            }
        }

        // link dst input data to src input data
        for (int i = 0; i < dst_data_in_pin.size(); i++)
        {
            if (i < src_data_in_pin.size())
            {
                auto dst_data_in_link_pin = m_Document->m_Blueprint.GetPinFromID(dst_data_in_pin[i]->m_Link);
                std::pair<Pin *, Pin *> re_link_in(src_data_in_pin[i], dst_data_in_link_pin);
                relink_pairs.push_back(re_link_in);
            }
        }
    }
    // we need unlink all flow pin first, in case link check dead loop
    for (auto pair : relink_pairs)
    {
        if (pair.first->GetType() == PinType::Flow)
            pair.first->Unlink();
    }
    for (auto pair : relink_pairs)
    {
        if (pair.first && pair.second)
        {
            pair.first->LinkTo(*pair.second);
        }
    }

    ed::SetNodePosition(src->m_ID, dst_pos);
    ed::SetNodePosition(dst->m_ID, src_pos);
    m_Document->m_Blueprint.SwapNode(src_id, dst_id);
    File_MarkModified();
    //ed::SetCurrentEditor(nullptr);
    EndOpRecord();
    return true;
}

bool BluePrintUI::Blueprint_DeleteNode(ID_TYPE id)
{
    if (!m_Document)
        return false;
    if (!Blueprint_IsValid())
        return false;
    auto deferredTransaction = m_Document->GetDeferredUndoTransaction("Destroy Action");
    BeginOpRecord("DestroyAction");
    ed::SetCurrentEditor(m_Editor);
    auto result = ed::DeleteNode(id);
    if (result)
    {
        //HandleDestroyAction();
        deferredTransaction->Begin("Delete Item");
        auto node = m_Document->m_Blueprint.FindNode(id);
        if (node && node->GetStyle() != NodeStyle::Group)
        {
            vector<std::pair<Pin *, Pin *>> relink_pairs;
            node->OnNodeDelete();
            if (m_CallBacks.BluePrintOnChanged)
            {
                auto ret = m_CallBacks.BluePrintOnChanged(BP_CB_NODE_DELETED, m_Document->m_Name, m_UserHandle);
                if (ret == BP_CBR_AutoLink)
                {
                    HandleAutoLink(node, relink_pairs);
                }
            }
            // unlink flow out pin
            for (auto pin : node->GetOutputPins())
            {
                if (pin->GetType() == PinType::Flow) pin->Unlink();
            }
            // unlink data in pin
            for (auto pin : node->GetInputPins())
            {
                if (pin->GetType() != PinType::Flow)pin->Unlink();
            }
            // delete node from blueprint
            m_Document->m_Blueprint.DeleteNode(node);
            // Check if we have re-link pin
            for (auto pair : relink_pairs)
            {
                pair.first->LinkTo(*pair.second);
                if (m_CallBacks.BluePrintOnChanged)
                {
                    auto ret = m_CallBacks.BluePrintOnChanged(BP_CB_Link, m_Document->m_Name, m_UserHandle);
                }
            }
        }
        File_MarkModified();
    }
    EndOpRecord();
    return result;
}

bool BluePrintUI::Blueprint_UpdateNode(ID_TYPE id)
{
    if (!m_Document)
        return false;
    if (!Blueprint_IsValid())
        return false;
    ed::SetCurrentEditor(m_Editor);
    auto node = m_Document->m_Blueprint.FindNode(id);
    if (!node)
        return false;
    ed::SetNodeChanged(node->m_ID);
    ed::Update();
    return true;
}

imgui_json::value BluePrintUI::Blueprint_GetOpRecord() const
{
    return m_OpRecord;
}

bool BluePrintUI::File_Export(Node * group_node)
{
    const char *filters = "Group file (*.group *.gp){.group,.gp},.*";
    IGFD::FileDialogConfig config;
    config.path = ".";
    config.countSelectionMax = 1;
    config.flags = ImGuiFileDialogFlags_SaveFile_Default;
    config.userDatas = group_node;
    if (m_BookMarkPath.empty()) config.flags &= ~ImGuiFileDialogFlags_ShowBookmark;
    ImGuiFileDialog::Instance()->OpenDialog("##BlueprintUI##SaveGroupDlgKey", ICON_IGFD_FOLDER_OPEN " Save Group File", filters, config);
    return true;
}

void BluePrintUI::UpdateActions()
{
    //auto mostRecentlyOpenFiles = ImGui::MostRecentlyUsedList("BluePrintOpenList");
    auto hasDocument = File_IsOpen();
    auto hasUndo     = hasDocument && !m_Document->m_Undo.empty();
    auto hasRedo     = hasDocument && !m_Document->m_Redo.empty();
    auto isModified  = hasDocument && File_IsModified();
    auto entryNode = FindEntryPointNode();
    auto exitNode = FindExitPointNode();
    bool hasBlueprint = true;
    bool hasEntryPoint = (entryNode != nullptr);
    bool hasExitPoint = (exitNode != nullptr);
    bool isExecuting   = m_Document->m_Blueprint.CurrentNode() != nullptr;
    bool hasSelectedNode   = GetSelectedNodes(&m_Document->m_Blueprint).size() > 0;
    bool hasSelectedLink   = GetSelectedLinks(&m_Document->m_Blueprint).size() > 0;
    bool hasClipBoardNodes = m_ClipBoard.size() > 0;
    bool isThreadExecuting = m_Document->m_Blueprint.IsExecuting();
    bool isThreadPaused = m_Document->m_Blueprint.IsPaused();
    bool isEditable = true;
    bool hasExportedLink = false;
    if (hasSelectedLink)
    {
        auto links = GetSelectedLinks(&m_Document->m_Blueprint);
        for (auto pin : links)
        {
            if (pin->IsLinkedExportedPin())
            {
                hasExportedLink = true;
                break;
            }
        }
    }

    if (isThreadExecuting && !isThreadPaused) ImGui::UpdateData(); // keep fleshing output if BP is running

    auto select_nodes = GetSelectedNodes(&m_Document->m_Blueprint);
    for (auto node : select_nodes)
    {
        if (node->GetTypeInfo().m_Type == NodeType::EntryPoint)
            isEditable = false;
        if (node->GetTypeInfo().m_Type == NodeType::ExitPoint)
            isEditable = false;
    }

    m_File_Open.SetEnabled(!isThreadExecuting);
    m_File_New.SetEnabled(!isThreadExecuting);
    m_File_Close.SetEnabled(hasDocument && !isThreadExecuting);
    m_File_SaveAs.SetEnabled(hasDocument && !isThreadExecuting);
    m_File_Save.SetEnabled(hasDocument && !isThreadExecuting);
    m_Edit_Undo.SetEnabled(hasUndo && (!isThreadExecuting || isThreadPaused));
    m_Edit_Redo.SetEnabled(hasRedo && (!isThreadExecuting || isThreadPaused));
    m_Edit_Cut.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused) && isEditable);
    m_Edit_Copy.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused) && isEditable);
    m_Edit_Paste.SetEnabled(hasDocument && hasClipBoardNodes && (!isThreadExecuting || isThreadPaused) && isEditable);
    m_Edit_Duplicate.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused) && isEditable);
    m_Edit_Delete.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused) && isEditable);
    m_Edit_Unlink.SetEnabled(hasDocument && hasSelectedLink && !hasExportedLink && (!isThreadExecuting || isThreadPaused));
    m_Edit_Setting.SetEnabled(hasDocument && (!isThreadExecuting || isThreadPaused));
    m_View_NavigateBackward.SetEnabled(hasDocument && false);
    m_View_NavigateForward.SetEnabled(hasDocument && false);
    m_View_ShowFlow.SetEnabled(hasDocument && (!isThreadExecuting || isThreadPaused));
    m_View_ZoomToContent.SetEnabled(hasBlueprint);
    m_View_ZoomToSelection.SetEnabled(hasBlueprint);
    m_Blueprint_Stop.SetEnabled(hasBlueprint && (isExecuting || isThreadExecuting));
    m_Blueprint_Run.SetEnabled(hasBlueprint && hasEntryPoint && (!isThreadExecuting || isThreadPaused));
    m_Blueprint_Pause.SetEnabled(hasBlueprint && hasEntryPoint && isThreadExecuting && !isThreadPaused);
#if defined(__EMSCRIPTEN__)
    m_Blueprint_Next.SetEnabled(hasBlueprint && hasEntryPoint && isExecuting);
#else
    m_Blueprint_Next.SetEnabled(hasBlueprint && hasEntryPoint && isThreadExecuting && isThreadPaused);
#endif
    m_Blueprint_Current.SetEnabled(hasBlueprint && hasEntryPoint && isThreadExecuting && isThreadPaused);
}

void BluePrintUI::ShowStyleEditor(bool* show)
{
    if (!ImGui::Begin("Edit Style", show))
    {
        ImGui::End();
        return;
    }
    float paneWidth = 600;
    auto& editorStyle = ed::GetStyle();
    ImGui::BeginHorizontal("Style buttons", ImVec2(paneWidth, 0), 1.0f);
    ImGui::TextUnformatted("Values");
    ImGui::Spring();
    if (ImGui::Button("Reset to defaults"))
        editorStyle = ed::Style();
    ImGui::EndHorizontal();
    ImGui::Spacing();
    ImGui::DragFloat4("Node Padding", &editorStyle.NodePadding.x, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Node Rounding", &editorStyle.NodeRounding, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Node Border Width", &editorStyle.NodeBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Hovered Node Border Width", &editorStyle.HoveredNodeBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Selected Node Border Width", &editorStyle.SelectedNodeBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Pin Rounding", &editorStyle.PinRounding, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Pin Border Width", &editorStyle.PinBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Link Strength", &editorStyle.LinkStrength, 1.0f, 0.0f, 500.0f);
    //ImVec2  SourceDirection;
    //ImVec2  TargetDirection;
    ImGui::DragFloat("Scroll Duration", &editorStyle.ScrollDuration, 0.001f, 0.0f, 2.0f);
    ImGui::DragFloat("Flow Marker Distance", &editorStyle.FlowMarkerDistance, 1.0f, 1.0f, 200.0f);
    ImGui::DragFloat("Flow Speed", &editorStyle.FlowSpeed, 1.0f, 1.0f, 2000.0f);
    ImGui::DragFloat("Flow Duration", &editorStyle.FlowDuration, 0.001f, 0.0f, 5.0f);
    //ImVec2  PivotAlignment;
    //ImVec2  PivotSize;
    //ImVec2  PivotScale;
    //float   PinCorners;
    //float   PinRadius;
    //float   PinArrowSize;
    //float   PinArrowWidth;
    ImGui::DragFloat("Group Rounding", &editorStyle.GroupRounding, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Group Border Width", &editorStyle.GroupBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::Separator();
    static ImGuiColorEditFlags edit_mode = ImGuiColorEditFlags_DisplayRGB;
    ImGui::BeginHorizontal("Color Mode", ImVec2(paneWidth, 0), 1.0f);
    ImGui::TextUnformatted("Filter Colors");
    ImGui::Spring();
    ImGui::RadioButton("RGB", &edit_mode, ImGuiColorEditFlags_DisplayRGB);
    ImGui::Spring(0);
    ImGui::RadioButton("HSV", &edit_mode, ImGuiColorEditFlags_DisplayHSV);
    ImGui::Spring(0);
    ImGui::RadioButton("HEX", &edit_mode, ImGuiColorEditFlags_DisplayHex);
    ImGui::EndHorizontal();
    static ImGuiTextFilter filter;
    filter.Draw("##filter", paneWidth);
    ImGui::Spacing();
    for (int i = 0; i < ed::StyleColor_Count; ++i)
    {
        auto name = ed::GetStyleColorName((ed::StyleColor)i);
        if (!filter.PassFilter(name))
            continue;
        ImGui::ColorEdit4(name, &editorStyle.Colors[i].x, edit_mode);
    }
    ImGui::End();
}

void BluePrintUI::ShowShortToolbar(bool vertical, bool* show)
{
    auto& io = ImGui::GetIO();
    ImVec2 window_pos = ImGui::GetWindowPos();
    ImVec2 window_size = ImGui::GetWindowSize();
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings;
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        const ImGuiViewport* viewport = ImGui::GetWindowViewport();
        window_flags |= ImGuiWindowFlags_NoDocking;
        io.ConfigViewportsNoDecoration = true;
        ImGui::SetNextWindowViewport(viewport->ID);
    }
    auto execable = Blueprint_IsExecutable();
    ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background
    ImGui::PushStyleColor(ImGuiCol_Button, m_StyleColors[BluePrintStyleColor_ToolButton]);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_StyleColors[BluePrintStyleColor_ToolButtonHovered]);
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, m_StyleColors[BluePrintStyleColor_ToolButtonActive]);
    ImGui::PushStyleColor(ImGuiCol_Separator, ImVec4(1.0, 1.0, 1.0, 0.8));
    ImGui::PushStyleColor(ImGuiCol_TexGlyphShadow, ImVec4(0.1, 0.1, 0.1, 0.8));
    ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));

    ImGui::SetNextWindowPos(window_pos + ImVec2(vertical ? window_size.x - 48 : window_size.x - 432, 8));
    if (ImGui::Begin("##embedded_toolbar", show, window_flags))
    {
        ImVec2 bar_window_pos = ImGui::GetWindowPos();
        ImVec2 bar_window_size = ImGui::GetWindowSize();
        if (!execable)
            ImGui::GetWindowDrawList()->AddRectFilled(bar_window_pos, bar_window_pos + bar_window_size, IM_COL32(255, 0, 0, 128));
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            auto viewport = ImGui::GetWindowViewport();
            viewport->Flags |= ImGuiViewportFlags_TopMost;
        }
        auto toolbarAction = [](Action& action)
        {
            ImGui::ScopedDisableItem disableAction(!action.IsEnabled());
#if IMGUI_ICONS
            string title = action.GetIcon() + "##toolbar";
#else
            string title = action.GetName() + "##toolbar";
#endif
            if (ImGui::Button(title.c_str()))
            {
                action.Execute();
            }
        };
        toolbarAction(m_View_ShowFlow); ImGui::ShowTooltipOnHover("%s", m_View_ShowFlow.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_View_ZoomToContent); ImGui::ShowTooltipOnHover("%s", m_View_ZoomToContent.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_View_ZoomToSelection); ImGui::ShowTooltipOnHover("%s", m_View_ZoomToSelection.GetName().c_str());
        if (!vertical) { ImGui::SameLine(); ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical); ImGui::SameLine(); }
        else ImGui::SeparatorEx(ImGuiSeparatorFlags_Horizontal);
        toolbarAction(m_Edit_Copy); ImGui::ShowTooltipOnHover("%s", m_Edit_Copy.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Paste); ImGui::ShowTooltipOnHover("%s", m_Edit_Paste.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Cut); ImGui::ShowTooltipOnHover("%s", m_Edit_Cut.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Duplicate); ImGui::ShowTooltipOnHover("%s", m_Edit_Duplicate.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Delete); ImGui::ShowTooltipOnHover("%s", m_Edit_Delete.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Unlink); ImGui::ShowTooltipOnHover("%s", m_Edit_Unlink.GetName().c_str());
        if (!vertical) { ImGui::SameLine(); ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical); ImGui::SameLine(); }
        else ImGui::SeparatorEx(ImGuiSeparatorFlags_Horizontal);
        toolbarAction(m_Edit_Undo); ImGui::ShowTooltipOnHover("%s", m_Edit_Undo.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Redo); ImGui::ShowTooltipOnHover("%s", m_Edit_Redo.GetName().c_str());
        // Show Info tooltip
        if (!vertical) { ImGui::SameLine(); ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical); ImGui::SameLine(); }
        else ImGui::SeparatorEx(ImGuiSeparatorFlags_Horizontal);
        string info_button_title = string(ICON_MD_INFO_OUTLINE) + "##info_tooltips";
        ImGui::CheckButton(info_button_title.c_str(), &m_isShowInfoTooltips, ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive));
        ImGui::ShowTooltipOnHover("Show Info in tooltips");
        //ImGui::SameLine();
        //ImGui::Text("%s", Blueprint_IsExecutable() ? "R" : "X");
        // Show Thumbnails
        //if (!vertical) { ImGui::SameLine(); ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical); ImGui::SameLine(); }
        //else ImGui::SeparatorEx(ImGuiSeparatorFlags_Horizontal);
        //string thumbnail_button_title = string(ICON_THUMBNAIL) + "##thumbnails";
        //ImGui::CheckButton(thumbnail_button_title.c_str(), &m_isShowThumbnails, ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive));
        //ImGui::ShowTooltipOnHover("Show Thumbnails");
        // show debug info
        //if (!vertical) { ImGui::SameLine(); ImGui::Text("%f (%f,%f)", ed::GetCurrentZoom(), ed::GetCurrentOrigin().x, ed::GetCurrentOrigin().y); }
    }
    ImGui::End();
    ImGui::PopStyleVar();
    ImGui::PopStyleColor(5);
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        io.ConfigViewportsNoDecoration = false;
    }
}

void BluePrintUI::ShowToolbar(bool* show)
{
    auto& io = ImGui::GetIO();
    ImVec2 window_pos = ImGui::GetWindowPos();
    ImVec2 window_size = ImGui::GetWindowSize();
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav;
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        const ImGuiViewport* viewport = ImGui::GetWindowViewport();
        window_flags |= ImGuiWindowFlags_NoDocking;
        io.ConfigViewportsNoDecoration = true;
        ImGui::SetNextWindowViewport(viewport->ID);
    }
    ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background
    ImGui::PushStyleColor(ImGuiCol_Button, m_StyleColors[BluePrintStyleColor_ToolButton]);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_StyleColors[BluePrintStyleColor_ToolButtonHovered]);
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, m_StyleColors[BluePrintStyleColor_ToolButtonActive]);
    ImGui::PushStyleColor(ImGuiCol_TexGlyphShadow, ImVec4(0.1, 0.1, 0.1, 0.8));
    ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));
    if (ImGui::Begin("##floating_toolbar", show, window_flags))
    {
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            auto viewport = ImGui::GetWindowViewport();
            viewport->Flags |= ImGuiViewportFlags_TopMost;
        }
        auto toolbarAction = [](Action& action)
        {
            ImGui::ScopedDisableItem disableAction(!action.IsEnabled());
#if IMGUI_ICONS
            string title = action.GetIcon() + "##toolbar";
#else
            string title = action.GetName() + "##toolbar";
#endif
            if (ImGui::Button(title.c_str()))
            {
                action.Execute();
            }
        };

        ImGui::Dummy(ImVec2(8, 0));
        ImGui::SameLine();
        toolbarAction(m_File_Exit); ImGui::ShowTooltipOnHover("%s", m_File_Exit.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        toolbarAction(m_File_Open); ImGui::ShowTooltipOnHover("%s", m_File_Open.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_File_New); ImGui::ShowTooltipOnHover("%s", m_File_New.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_File_Save); ImGui::ShowTooltipOnHover("%s", m_File_Save.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_File_SaveAs); ImGui::ShowTooltipOnHover("%s", m_File_SaveAs.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        toolbarAction(m_Edit_Undo); ImGui::ShowTooltipOnHover("%s", m_Edit_Undo.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Redo); ImGui::ShowTooltipOnHover("%s", m_Edit_Redo.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Copy); ImGui::ShowTooltipOnHover("%s", m_Edit_Copy.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Paste); ImGui::ShowTooltipOnHover("%s", m_Edit_Paste.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Cut); ImGui::ShowTooltipOnHover("%s", m_Edit_Cut.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Duplicate); ImGui::ShowTooltipOnHover("%s", m_Edit_Duplicate.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Delete); ImGui::ShowTooltipOnHover("%s", m_Edit_Delete.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Unlink); ImGui::ShowTooltipOnHover("%s", m_Edit_Unlink.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        toolbarAction(m_View_ShowFlow); ImGui::ShowTooltipOnHover("%s", m_View_ShowFlow.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_View_ZoomToContent); ImGui::ShowTooltipOnHover("%s", m_View_ZoomToContent.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_View_ZoomToSelection); ImGui::ShowTooltipOnHover("%s", m_View_ZoomToSelection.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Run); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Run.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Pause); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Pause.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Next); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Next.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Current); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Current.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Stop); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Stop.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::CheckButton(ICON_MD_INFO_OUTLINE "##info_tooltips", &m_isShowInfoTooltips, ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive));
        ImGui::ShowTooltipOnHover("Show Info in tooltips");
        ImGui::SameLine();
        ImGui::CheckButton(ICON_SETTING_PANEL "##setting_panel", &m_ShowSettingPanel, ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive));
        ImGui::ShowTooltipOnHover("Show Setting Panel");
        ImGui::SameLine();
        ImGui::CheckButton(ICON_THUMBNAIL "##thumbnails", &m_isShowThumbnails, ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive));
        ImGui::ShowTooltipOnHover("Show Thumbnails");
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::Text("%d(%s)", m_Document->m_Blueprint.StepCount(), StepResultToString(m_Document->m_Blueprint.LastStepResult()));
        ImGui::SameLine();
        ImGui::Text("%.3fms/%.1fFPS(%d/%d)", ImGui::GetIO().DeltaTime * 1000.f, ImGui::GetIO().Framerate, ImGui::GetIO().FrameCountSinceLastUpdate, ImGui::GetIO().FrameCountSinceLastEvent);
        ImGui::SameLine();
        //ImGui::Text("%s", Blueprint_IsExecutable() ? "R" : "X");
        //ImGui::SameLine();
        ImGui::Dummy(ImVec2(20, 0));
    }
    ImGui::End();
    ImGui::PopStyleVar();
    ImGui::PopStyleColor(4);
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        io.ConfigViewportsNoDecoration = false;
    }
}

void BluePrintUI::ShowSettingPanel(bool* show)
{
    if (show && !*show)
        return;
    auto& io = ImGui::GetIO();
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_TitleBarBold;
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        const ImGuiViewport* viewport = ImGui::GetWindowViewport();
        io.ConfigViewportsNoDecoration = true;
        ImGui::SetNextWindowViewport(viewport->ID);
    }
    ImGui::SetNextWindowBgAlpha(0.5f); // Transparent background
    ImGui::PushStyleColor(ImGuiCol_Button, m_StyleColors[BluePrintStyleColor_ToolButton]);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_StyleColors[BluePrintStyleColor_ToolButtonHovered]);
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, m_StyleColors[BluePrintStyleColor_ToolButtonActive]);
    ImGui::PushStyleColor(ImGuiCol_TexGlyphShadow, ImVec4(0.1, 0.1, 0.1, 0.8));
    ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));
    if (ImGui::Begin("Setting Panel", show, window_flags))
    {
        for (auto node : m_Document->m_Blueprint.GetNodes())
        {
            auto type = node->GetTypeInfo().m_Type;
            if (type == BluePrint::NodeType::EntryPoint || type == BluePrint::NodeType::ExitPoint)
                continue;
            if (!node->IsSelected())
                continue;
            auto label_name = node->m_Name;
            std::string lable_id = label_name + "##node_setting" + "@" + std::to_string(node->m_ID);
            auto node_pos = ImGui::GetCursorScreenPos();
            node->DrawNodeLogo(ImGui::GetCurrentContext(), ImVec2(60, 30));
            ImGui::SameLine(60);
            ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0, 1.0, 1.0, 1.0));
            ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.5, 0.5, 0.0, 0.5));
            ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.2, 0.5, 0.2, 0.5));
            ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.1, 0.5, 0.1, 0.5));
            ImGuiTreeNodeFlags tree_flags = ImGuiTreeNodeFlags_SpanFullWidth | ImGuiTreeNodeFlags_AllowOverlap;
            tree_flags |= ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Selected;
            bool tree_open = ImGui::TreeNodeEx(lable_id.c_str(), tree_flags);
            ImGui::PopStyleColor(4);
            if (tree_open)
            {
                if (node->DrawSettingLayout(ImGui::GetCurrentContext()))
                {
                    File_MarkModified();
                    ed::SetNodeChanged(node->m_ID);
                    if (m_CallBacks.BluePrintOnChanged)
                    {
                        m_CallBacks.BluePrintOnChanged(BP_CB_SETTING_CHANGED, m_Document->m_Name, m_UserHandle);
                    }
                }
                ImGui::TreePop();
            }
            ImGui::PushStyleColor(ImGuiCol_Separator, ImVec4(1,1,1,1));
            ImGui::Separator();
            ImGui::PopStyleColor();
        }
    }
    ImGui::End();
    ImGui::PopStyleVar();
    ImGui::PopStyleColor(4);
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        io.ConfigViewportsNoDecoration = false;
    }
}

void BluePrintUI::Thumbnails(float view_expand, ImVec2 size, ImVec2 pos)
{
    auto& io = ImGui::GetIO();
    float zoom = ed::GetCurrentZoom();
    auto screen_size = (size.x == 0 || size.y == 0) ? ed::GetScreenSize() : size;
    auto screen_pos = (pos.x < 0 || pos.y < 0) ? screen_size - screen_size * m_ThumbnailScale : pos;
    auto view_rect = ed::GetViewRect();
    auto view_size = view_rect.GetSize();
    auto view_center = view_rect.GetCenter();
    if (view_expand < 1.f) view_expand = 1.0f;
    float view_scale = 1.f / view_expand;
    ImRect screen_rect(ImVec2(view_center.x - view_size.x * view_expand / 2.f, view_center.y - view_size.y * view_expand / 2.f), 
                        ImVec2(view_center.x + view_size.x * view_expand / 2.f, view_center.y + view_size.y * view_expand / 2.f));

    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoInputs;
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        const ImGuiViewport* viewport = ImGui::GetWindowViewport();
        window_flags |= ImGuiWindowFlags_NoDocking;
        io.ConfigViewportsNoDecoration = true;
        ImGui::SetNextWindowViewport(viewport->ID);
    }
    float window_alpha = 0.5f;
    if (m_ThumbnailShowCount > 0)
    {
        if (m_isShowThumbnails)
            m_ThumbnailShowCount = 0;
        else if (m_ThumbnailShowCount <= THUMBNAIL_HIDDEN)
            window_alpha *= (float)m_ThumbnailShowCount / (float)THUMBNAIL_HIDDEN;
    }
    ImGui::SetNextWindowBgAlpha(window_alpha);
    ImGui::SetNextWindowPos(screen_pos);
    ImGui::SetNextWindowSize(screen_size * m_ThumbnailScale);
    if (ImGui::Begin("##floating_thumbnails", nullptr, window_flags))
    {
        auto cursorPos = ImGui::GetCursorScreenPos();
        auto window = ImGui::GetCurrentWindow();
        auto drawList  = ImGui::GetWindowDrawList();
        auto view_area_pos = (view_rect.Min - screen_rect.Min) * m_ThumbnailScale * view_scale / zoom;
        auto view_area_size = view_size * m_ThumbnailScale * view_scale / zoom;
        drawList->AddRect(cursorPos + view_area_pos, cursorPos + view_area_pos + view_area_size, ImGui::GetColorU32(ImGuiCol_Border, window_alpha));
        for (auto& node : m_Document->m_Blueprint.GetNodes())
        {
            auto node_pos = (ed::GetNodePosition(node->m_ID) - screen_rect.Min) * m_ThumbnailScale * view_scale / zoom;
            auto node_size = ed::GetNodeSize(node->m_ID) * m_ThumbnailScale * view_scale / zoom;
            if (node->IsSelected())
                drawList->AddRect(cursorPos + node_pos, cursorPos + node_pos + node_size, IM_COL32(255, 255, 0, window_alpha * 255));
            drawList->AddRectFilled(cursorPos + node_pos, cursorPos + node_pos + node_size, ImGui::GetColorU32(ImGuiCol_Border, window_alpha));
        }
    }
    ImGui::End();
    ImGui::UpdateData();
    m_ThumbnailShowCount --;
    if (m_ThumbnailShowCount <= 0) m_ThumbnailShowCount = 0;
}

void BluePrintUI::BeginOpRecord(const std::string& opName)
{
    if (m_OpRecord.contains("operation"))
    {
        std::ostringstream oss;
        oss << m_OpRecord["operation"].get<imgui_json::string>() << "|" << opName;
        m_OpRecord["operation"] = oss.str();
    }
    else
    {
        m_OpRecord["operation"] = opName;
        m_OpRecord["before_op_state"] = m_Document->Serialize();
    }
}

void BluePrintUI::EndOpRecord()
{
    if (!m_OpRecord.contains("operation"))
        return;
    if (m_CallBacks.BluePrintOnChanged)
    {
        m_OpRecord["after_op_state"] = m_Document->Serialize();
        m_CallBacks.BluePrintOnChanged(BP_CB_OPERATION_DONE, m_Document->m_Name, m_UserHandle);
    }
    m_OpRecord = imgui_json::value();
}

void BluePrintUI::ClearOpRecord()
{
    m_OpRecord = imgui_json::value();
}
} // namespace BluePrint

//-----------------------------------------------------------------------------

// Stack Layout
namespace ImGui
{
static ImGuiLayout*     FindLayout(ImGuiID id, ImGuiLayoutType type);
static ImGuiLayout*     CreateNewLayout(ImGuiID id, ImGuiLayoutType type, ImVec2 size);
static void             BeginLayout(ImGuiID id, ImGuiLayoutType type, ImVec2 size, float align);
static void             EndLayout(ImGuiLayoutType type);
static void             PushLayout(ImGuiLayout* layout);
static void             PopLayout(ImGuiLayout* layout);
static void             BalanceLayoutSprings(ImGuiLayout& layout);
static ImVec2           BalanceLayoutItemAlignment(ImGuiLayout& layout, ImGuiLayoutItem& item);
static void             BalanceLayoutItemsAlignment(ImGuiLayout& layout);
static void             BalanceChildLayouts(ImGuiLayout& layout);
static ImVec2           CalculateLayoutSize(ImGuiLayout& layout, bool collapse_springs);
static ImGuiLayoutItem* GenerateLayoutItem(ImGuiLayout& layout, ImGuiLayoutItemType type);
static float            CalculateLayoutItemAlignmentOffset(ImGuiLayout& layout, ImGuiLayoutItem& item);
static void             TranslateLayoutItem(ImGuiLayoutItem& item, const ImVec2& offset);
static void             BeginLayoutItem(ImGuiLayout& layout);
static void             EndLayoutItem(ImGuiLayout& layout);
static void             AddLayoutSpring(ImGuiLayout& layout, float weight, float spacing);
static void             SignedIndent(float indent);

static ImGuiLayout* FindLayout(ImGuiID id, ImGuiLayoutType type)
{
    IM_ASSERT(type == ImGuiLayoutType_Horizontal || type == ImGuiLayoutType_Vertical);

    ImGuiWindow* window = GetCurrentWindow();
    ImGuiLayout* layout = (ImGuiLayout*)window->DC.Layouts.GetVoidPtr(id);
    if (!layout)
        return NULL;

    if (layout->Type != type)
    {
        layout->Type = type;
        layout->MinimumSize = ImVec2(0.0f, 0.0f);
        layout->Items.clear();
    }

    return layout;
}

static ImGuiLayout* CreateNewLayout(ImGuiID id, ImGuiLayoutType type, ImVec2 size)
{
    IM_ASSERT(type == ImGuiLayoutType_Horizontal || type == ImGuiLayoutType_Vertical);

    ImGuiWindow* window = GetCurrentWindow();

    ImGuiLayout* layout = IM_NEW(ImGuiLayout)(id, type);
    layout->Size = size;

    window->DC.Layouts.SetVoidPtr(id, layout);

    return layout;
}

static void BeginLayout(ImGuiID id, ImGuiLayoutType type, ImVec2 size, float align)
{
    ImGuiWindow* window = GetCurrentWindow();

    PushID(id);

    // Find or create
    ImGuiLayout* layout = FindLayout(id, type);
    if (!layout)
        layout = CreateNewLayout(id, type, size);

    layout->Live = true;

    PushLayout(layout);

    if (layout->Size.x != size.x || layout->Size.y != size.y)
        layout->Size = size;

    if (align < 0.0f)
        layout->Align = -1.0f;
    else
        layout->Align = ImClamp(align, 0.0f, 1.0f);

    // Start capture
    layout->CurrentItemIndex = 0;

    layout->CurrentSize.x = layout->Size.x > 0.0f ? layout->Size.x : layout->MinimumSize.x;
    layout->CurrentSize.y = layout->Size.y > 0.0f ? layout->Size.y : layout->MinimumSize.y;

    layout->StartPos = window->DC.CursorPos;
    layout->StartCursorMaxPos = window->DC.CursorMaxPos;

    if (type == ImGuiLayoutType_Vertical)
    {
        // Push empty item to recalculate cursor position.
        PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0.0f, 0.0f));
        Dummy(ImVec2(0.0f, 0.0f));
        PopStyleVar();

        // Indent horizontal position to match edge of the layout.
        layout->Indent = layout->StartPos.x - window->DC.CursorPos.x;
        SignedIndent(layout->Indent);
    }

    BeginLayoutItem(*layout);
}

static void LayoutItemSize(const ImVec2& size, float text_baseline_y = -1.0f)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    const ImVec2 line_size = ImMax(window->DC.CurrLineSize, size);
    ImGuiLayoutType layout_type = window->DC.LayoutType;
    if (window->DC.CurrentLayout)
        layout_type = window->DC.CurrentLayout->Type;
    if (layout_type == ImGuiLayoutType_Vertical)
    {
        const float text_base_offset = ImMax(window->DC.CurrLineTextBaseOffset, text_baseline_y);

        window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);
        window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
        window->DC.CursorPos.y = (float)(int)(window->DC.CursorPos.y + line_size.y + g.Style.ItemSpacing.y);
        window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
        window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);

        window->DC.PrevLineSize = ImVec2(0.0f, line_size.y);
        window->DC.CurrLineSize.y = 0.0f;
        window->DC.CurrLineTextBaseOffset = 0.0f;
        window->DC.PrevLineTextBaseOffset = text_base_offset;
        window->DC.IsSameLine = window->DC.IsSetPos = false;
    }
    else
    {
        window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x, window->DC.CursorPos.y + size.y);
        window->DC.CursorPos.x = (float)(int)(window->DC.CursorPos.x + line_size.x + g.Style.ItemSpacing.x);
        window->DC.CursorPos.y = (float)(int)(window->DC.CursorPosPrevLine.y - size.y);
        window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x - g.Style.ItemSpacing.x);
        window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPosPrevLine.y);

        window->DC.PrevLineSize = ImVec2(line_size.x, 0.0f);
        window->DC.CurrLineSize.x = 0.0f;
    }
}

static void EndLayout(ImGuiLayoutType type)
{
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(window->DC.CurrentLayout);
    IM_ASSERT(window->DC.CurrentLayout->Type == type);

    ImGuiLayout* layout = window->DC.CurrentLayout;

    EndLayoutItem(*layout);

    if (layout->CurrentItemIndex < layout->Items.Size)
        layout->Items.resize(layout->CurrentItemIndex);

    if (layout->Type == ImGuiLayoutType_Vertical)
        SignedIndent(-layout->Indent);

    PopLayout(layout);

    const bool auto_width  = layout->Size.x <= 0.0f;
    const bool auto_height = layout->Size.y <= 0.0f;

    ImVec2 new_size = layout->Size;
    if (auto_width)
        new_size.x = layout->CurrentSize.x;
    if (auto_height)
        new_size.y = layout->CurrentSize.y;

    ImVec2 new_minimum_size = CalculateLayoutSize(*layout, true);

    if (new_minimum_size.x != layout->MinimumSize.x || new_minimum_size.y != layout->MinimumSize.y)
    {
        layout->MinimumSize = new_minimum_size;

        // Shrink
        if (auto_width)
            new_size.x = new_minimum_size.x;
        if (auto_height)
            new_size.y = new_minimum_size.y;
    }

    if (!auto_width)
        new_size.x = layout->Size.x;
    if (!auto_height)
        new_size.y = layout->Size.y;

    layout->CurrentSize = new_size;

    ImVec2 measured_size = new_size;
    if ((auto_width || auto_height) && layout->Parent)
    {
        if (layout->Type == ImGuiLayoutType_Horizontal && auto_width && layout->Parent->CurrentSize.x > 0)
            layout->CurrentSize.x = layout->Parent->CurrentSize.x;
        else if (layout->Type == ImGuiLayoutType_Vertical && auto_height && layout->Parent->CurrentSize.y > 0)
            layout->CurrentSize.y = layout->Parent->CurrentSize.y;

        BalanceLayoutSprings(*layout);

        measured_size = layout->CurrentSize;
    }

    layout->CurrentSize = new_size;

    PopID();

    ImVec2 current_layout_item_max = ImVec2(0.0f, 0.0f);
    if (window->DC.CurrentLayoutItem)
        current_layout_item_max = ImMax(window->DC.CurrentLayoutItem->MeasuredBounds.Max, layout->StartPos + new_size);

    window->DC.CursorPos    = layout->StartPos;
    window->DC.CursorMaxPos = layout->StartCursorMaxPos;
    LayoutItemSize(new_size);
    ItemAdd(ImRect(layout->StartPos, layout->StartPos + measured_size), 0);

    if (window->DC.CurrentLayoutItem)
        window->DC.CurrentLayoutItem->MeasuredBounds.Max = current_layout_item_max;

    if (layout->Parent == NULL)
        BalanceChildLayouts(*layout);
}

static ImVec2 CalculateLayoutSize(ImGuiLayout& layout, bool collapse_springs)
{
    ImVec2 bounds = ImVec2(0.0f, 0.0f);

    if (layout.Type == ImGuiLayoutType_Vertical)
    {
        for (int i = 0; i < layout.Items.Size; i++)
        {
            ImGuiLayoutItem& item = layout.Items[i];
            ImVec2 item_size = item.MeasuredBounds.GetSize();

            if (item.Type == ImGuiLayoutItemType_Item)
            {
                bounds.x  = ImMax(bounds.x, item_size.x);
                bounds.y += item_size.y;
            }
            else
            {
                bounds.y += ImFloor(item.SpringSpacing);

                if (!collapse_springs)
                    bounds.y += item.SpringSize;
            }
        }
    }
    else
    {
        for (int i = 0; i < layout.Items.Size; i++)
        {
            ImGuiLayoutItem& item = layout.Items[i];
            ImVec2 item_size = item.MeasuredBounds.GetSize();

            if (item.Type == ImGuiLayoutItemType_Item)
            {
                bounds.x += item_size.x;
                bounds.y  = ImMax(bounds.y, item_size.y);
            }
            else
            {
                bounds.x += ImFloor(item.SpringSpacing);

                if (!collapse_springs)
                    bounds.x += item.SpringSize;
            }
        }
    }

    return bounds;
}

static void PushLayout(ImGuiLayout* layout)
{
    ImGuiWindow* window = GetCurrentWindow();

    if (layout)
    {
        layout->Parent = window->DC.CurrentLayout;
        if (layout->Parent != NULL)
            layout->ParentItemIndex = layout->Parent->CurrentItemIndex;
        if (window->DC.CurrentLayout)
        {
            layout->NextSibling = window->DC.CurrentLayout->FirstChild;
            layout->FirstChild  = NULL;
            window->DC.CurrentLayout->FirstChild = layout;
        }
        else
        {
            layout->NextSibling = NULL;
            layout->FirstChild  = NULL;
        }
    }

    window->DC.LayoutStack.push_back(layout);
    window->DC.CurrentLayout = layout;
    window->DC.CurrentLayoutItem = NULL;
}

static void PopLayout(ImGuiLayout* layout)
{
    ImGuiWindow* window = GetCurrentWindow();

    IM_ASSERT(!window->DC.LayoutStack.empty());
    IM_ASSERT(window->DC.LayoutStack.back() == layout);

    window->DC.LayoutStack.pop_back();

    if (!window->DC.LayoutStack.empty())
    {
        window->DC.CurrentLayout = window->DC.LayoutStack.back();
        window->DC.CurrentLayoutItem = &window->DC.CurrentLayout->Items[window->DC.CurrentLayout->CurrentItemIndex];
    }
    else
    {
        window->DC.CurrentLayout = NULL;
        window->DC.CurrentLayoutItem = NULL;
    }
}

static void BalanceLayoutSprings(ImGuiLayout& layout)
{
    // Accumulate amount of occupied space and springs weights
    float total_spring_weight = 0.0f;

    int last_spring_item_index = -1;
    for (int i = 0; i < layout.Items.Size; i++)
    {
        ImGuiLayoutItem& item = layout.Items[i];
        if (item.Type == ImGuiLayoutItemType_Spring)
        {
            total_spring_weight += item.SpringWeight;
            last_spring_item_index = i;
        }
    }

    // Determine occupied space and available space depending on layout type
    const bool  is_horizontal   = (layout.Type == ImGuiLayoutType_Horizontal);
    const bool  is_auto_sized   = ((is_horizontal ? layout.Size.x : layout.Size.y) <= 0.0f) && (layout.Parent == NULL);
    const float occupied_space  = is_horizontal ? layout.MinimumSize.x : layout.MinimumSize.y;
    const float available_space = is_auto_sized ? occupied_space : (is_horizontal ? layout.CurrentSize.x : layout.CurrentSize.y);
    const float free_space      = ImMax(available_space - occupied_space, 0.0f);

    float span_start     = 0.0f;
    float current_weight = 0.0f;
    for (int i = 0; i < layout.Items.Size; i++)
    {
        ImGuiLayoutItem& item = layout.Items[i];
        if (item.Type != ImGuiLayoutItemType_Spring)
            continue;

        float last_spring_size = item.SpringSize;

        if (free_space > 0.0f && total_spring_weight > 0.0f)
        {
            float next_weight = current_weight + item.SpringWeight;
            float span_end    = ImFloor((i == last_spring_item_index) ? free_space : (free_space * next_weight / total_spring_weight));
            float spring_size = span_end - span_start;
            item.SpringSize   = spring_size;
            span_start        = span_end;
            current_weight    = next_weight;
        }
        else
        {
            item.SpringSize = 0.0f;
        }

        // If spring changed its size, fix positioning of following items to avoid one frame visual bugs.
        if (last_spring_size != item.SpringSize)
        {
            float difference = item.SpringSize - last_spring_size;

            ImVec2 offset = is_horizontal ? ImVec2(difference, 0.0f) : ImVec2(0.0f, difference);

            item.MeasuredBounds.Max += offset;

            for (int j = i + 1; j < layout.Items.Size; j++)
            {
                ImGuiLayoutItem& translated_item = layout.Items[j];

                TranslateLayoutItem(translated_item, offset);

                translated_item.MeasuredBounds.Min += offset;
                translated_item.MeasuredBounds.Max += offset;
            }
        }
    }
}

static ImVec2 BalanceLayoutItemAlignment(ImGuiLayout& layout, ImGuiLayoutItem& item)
{
    // Fixup item alignment if necessary.
    ImVec2 position_correction = ImVec2(0.0f, 0.0f);
    if (item.CurrentAlign > 0.0f)
    {
        float item_align_offset = CalculateLayoutItemAlignmentOffset(layout, item);
        if (item.CurrentAlignOffset != item_align_offset)
        {
            float offset = item_align_offset - item.CurrentAlignOffset;

            if (layout.Type == ImGuiLayoutType_Horizontal)
                position_correction.y = offset;
            else
                position_correction.x = offset;

            TranslateLayoutItem(item, position_correction);

            item.CurrentAlignOffset = item_align_offset;
        }
    }

    return position_correction;
}

static void BalanceLayoutItemsAlignment(ImGuiLayout& layout)
{
    for (int i = 0; i < layout.Items.Size; ++i)
    {
        ImGuiLayoutItem& item = layout.Items[i];
        BalanceLayoutItemAlignment(layout, item);
    }
}

static bool HasAnyNonZeroSpring(ImGuiLayout& layout)
{
    for (int i = 0; i < layout.Items.Size; ++i)
    {
        ImGuiLayoutItem& item = layout.Items[i];
        if (item.Type != ImGuiLayoutItemType_Spring)
            continue;
        if (item.SpringWeight > 0)
            return true;
    }
    return false;
}

static void BalanceChildLayouts(ImGuiLayout& layout)
{
    for (ImGuiLayout* child = layout.FirstChild; child != NULL; child = child->NextSibling)
    {
        //ImVec2 child_layout_size = child->CurrentSize;

        // Propagate layout size down to child layouts.
        //
        // TODO: Distribution assume inner layout is only
        //       element inside parent item and assigns
        //       all available space to it.
        //
        //       Investigate how to split space between
        //       adjacent layouts.
        //
        //       Investigate how to measure non-layout items
        //       to treat them as fixed size blocks.
        //
        if (child->Type == ImGuiLayoutType_Horizontal && child->Size.x <= 0.0f)
            child->CurrentSize.x = layout.CurrentSize.x;
        else if (child->Type == ImGuiLayoutType_Vertical && child->Size.y <= 0.0f)
            child->CurrentSize.y = layout.CurrentSize.y;

        BalanceChildLayouts(*child);

        //child->CurrentSize = child_layout_size;

        if (HasAnyNonZeroSpring(*child))
        {
            // Expand item measured bounds to make alignment correct.
            ImGuiLayoutItem& item = layout.Items[child->ParentItemIndex];

            if (child->Type == ImGuiLayoutType_Horizontal && child->Size.x <= 0.0f)
                item.MeasuredBounds.Max.x = ImMax(item.MeasuredBounds.Max.x, item.MeasuredBounds.Min.x + layout.CurrentSize.x);
            else if (child->Type == ImGuiLayoutType_Vertical && child->Size.y <= 0.0f)
                item.MeasuredBounds.Max.y = ImMax(item.MeasuredBounds.Max.y, item.MeasuredBounds.Min.y + layout.CurrentSize.y);
        }
    }

    BalanceLayoutSprings(layout);
    BalanceLayoutItemsAlignment(layout);
}

static ImGuiLayoutItem* GenerateLayoutItem(ImGuiLayout& layout, ImGuiLayoutItemType type)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(layout.CurrentItemIndex <= layout.Items.Size);

    if (layout.CurrentItemIndex < layout.Items.Size)
    {
        ImGuiLayoutItem& item = layout.Items[layout.CurrentItemIndex];
        if (item.Type != type)
            item = ImGuiLayoutItem(type);
    }
    else
    {
        layout.Items.push_back(ImGuiLayoutItem(type));
    }

    g.CurrentWindow->DC.CurrentLayoutItem = &layout.Items[layout.CurrentItemIndex];

    return &layout.Items[layout.CurrentItemIndex];
}

static void SignedIndent(float indent)
{
    if (indent > 0.0f)
        Indent(indent);
    else if (indent < 0.0f)
        Unindent(-indent);
}

static void BeginLayoutItem(ImGuiLayout& layout)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiLayoutItem& item = *GenerateLayoutItem(layout, ImGuiLayoutItemType_Item);

    item.CurrentAlign = layout.Align;
    if (item.CurrentAlign < 0.0f)
    {
        // Element alignment inside horizontal and vertical layouts (0.0f - left/top, 1.0f - right/bottom, 0.5f - center).
        item.CurrentAlign = 0.5;
    }

    // Align item according to data from previous frame.
    // If layout changes in current frame alignment will 
    // be corrected in EndLayout() to it visualy coherent.
    item.CurrentAlignOffset = CalculateLayoutItemAlignmentOffset(layout, item);
    if (item.CurrentAlign > 0.0f)
    {
        if (layout.Type == ImGuiLayoutType_Horizontal)
        {
            window->DC.CursorPos.y += item.CurrentAlignOffset;
        }
        else
        {
            float new_position = window->DC.CursorPos.x + item.CurrentAlignOffset;

            // Make placement behave like in horizontal case when next
            // widget is placed at very same Y position. This indent
            // make sure for vertical layout placed widgets has same X position.
            SignedIndent(item.CurrentAlignOffset);

            window->DC.CursorPos.x = new_position;
        }
    }

    item.MeasuredBounds.Min = item.MeasuredBounds.Max = window->DC.CursorPos;
    item.VertexIndexBegin = item.VertexIndexEnd = window->DrawList->_VtxCurrentIdx;
}

// Calculate how many pixels from top/left layout edge item need to be moved to match
// layout alignment.
static float CalculateLayoutItemAlignmentOffset(ImGuiLayout& layout, ImGuiLayoutItem& item)
{
    if (item.CurrentAlign <= 0.0f)
        return 0.0f;

    ImVec2 item_size = item.MeasuredBounds.GetSize();

    float layout_extent = (layout.Type == ImGuiLayoutType_Horizontal) ? layout.CurrentSize.y : layout.CurrentSize.x;
    float item_extent   = (layout.Type == ImGuiLayoutType_Horizontal) ? item_size.y : item_size.x;

    if (item_extent <= 0/* || layout_extent <= item_extent*/)
        return 0.0f;

    float align_offset = ImFloor(item.CurrentAlign * (layout_extent - item_extent));

    return align_offset;
}

static void TranslateLayoutItem(ImGuiLayoutItem& item, const ImVec2& offset)
{
    if ((offset.x == 0.0f && offset.y == 0.0f) || (item.VertexIndexBegin == item.VertexIndexEnd))
        return;

    //IMGUI_DEBUG_LOG("TranslateLayoutItem by %f,%f\n", offset.x, offset.y);
    ImDrawList* draw_list = GetWindowDrawList();

    ImDrawVert* begin = draw_list->VtxBuffer.Data + item.VertexIndexBegin;
    ImDrawVert* end   = draw_list->VtxBuffer.Data + item.VertexIndexEnd;

    for (ImDrawVert* vtx = begin; vtx < end; ++vtx)
    {
        vtx->pos.x += offset.x;
        vtx->pos.y += offset.y;
    }
}

static void EndLayoutItem(ImGuiLayout& layout)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(layout.CurrentItemIndex < layout.Items.Size);

    ImGuiLayoutItem& item = layout.Items[layout.CurrentItemIndex];

    ImDrawList* draw_list = window->DrawList;
    item.VertexIndexEnd = draw_list->_VtxCurrentIdx;

    if (item.CurrentAlign > 0.0f && layout.Type == ImGuiLayoutType_Vertical)
        SignedIndent(-item.CurrentAlignOffset);

    // Fixup item alignment in case item size changed in current frame.
    ImVec2 position_correction = BalanceLayoutItemAlignment(layout, item);

    item.MeasuredBounds.Min += position_correction;
    item.MeasuredBounds.Max += position_correction;

    if (layout.Type == ImGuiLayoutType_Horizontal)
        window->DC.CursorPos.y = layout.StartPos.y;
    else
        window->DC.CursorPos.x = layout.StartPos.x;

    layout.CurrentItemIndex++;
}

static void AddLayoutSpring(ImGuiLayout& layout, float weight, float spacing)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiLayoutItem* previous_item = &layout.Items[layout.CurrentItemIndex];

    // Undo item padding, spring should consume all space between items.
    if (layout.Type == ImGuiLayoutType_Horizontal)
        window->DC.CursorPos.x = previous_item->MeasuredBounds.Max.x;
    else
        window->DC.CursorPos.y = previous_item->MeasuredBounds.Max.y;

    previous_item = NULL; // may be invalid after call to GenerateLayoutItem()

    EndLayoutItem(layout);

    ImGuiLayoutItem* spring_item = GenerateLayoutItem(layout, ImGuiLayoutItemType_Spring);

    spring_item->MeasuredBounds.Min = spring_item->MeasuredBounds.Max = window->DC.CursorPos;

    if (weight < 0.0f)
        weight = 0.0f;

    if (spring_item->SpringWeight != weight)
        spring_item->SpringWeight = weight;

    if (spacing < 0.0f)
    {
        ImVec2 style_spacing = g.Style.ItemSpacing;
        if (layout.Type == ImGuiLayoutType_Horizontal)
            spacing = style_spacing.x;
        else
            spacing = style_spacing.y;
    }

    if (spring_item->SpringSpacing != spacing)
        spring_item->SpringSpacing = spacing;

    if (spring_item->SpringSize > 0.0f || spacing > 0.0f)
    {
        ImVec2 spring_size, spring_spacing;
        if (layout.Type == ImGuiLayoutType_Horizontal)
        {
            spring_spacing = ImVec2(0.0f, g.Style.ItemSpacing.y);
            spring_size    = ImVec2(spacing + spring_item->SpringSize, layout.CurrentSize.y);
        }
        else
        {
            spring_spacing = ImVec2(g.Style.ItemSpacing.x, 0.0f);
            spring_size    = ImVec2(layout.CurrentSize.x, spacing + spring_item->SpringSize);
        }

        PushStyleVar(ImGuiStyleVar_ItemSpacing, ImFloor(spring_spacing));
        Dummy(ImFloor(spring_size));
        PopStyleVar();
    }

    layout.CurrentItemIndex++;

    BeginLayoutItem(layout);
}

// Stack Layout API
void BeginHorizontal(const char* str_id, const ImVec2& size/* = ImVec2(0, 0)*/, float align/* = -1*/)
{
    ImGuiWindow* window = GetCurrentWindow();
    BeginLayout(window->GetID(str_id), ImGuiLayoutType_Horizontal, size, align);
}

void BeginHorizontal(const void* ptr_id, const ImVec2& size/* = ImVec2(0, 0)*/, float align/* = -1*/)
{
    ImGuiWindow* window = GetCurrentWindow();
    BeginLayout(window->GetID(ptr_id), ImGuiLayoutType_Horizontal, size, align);
}

void BeginHorizontal(int id, const ImVec2& size/* = ImVec2(0, 0)*/, float align/* = -1*/)
{
    ImGuiWindow* window = GetCurrentWindow();
    BeginLayout(window->GetID((void*)(intptr_t)id), ImGuiLayoutType_Horizontal, size, align);
}

void EndHorizontal()
{
    EndLayout(ImGuiLayoutType_Horizontal);
}

void BeginVertical(const char* str_id, const ImVec2& size/* = ImVec2(0, 0)*/, float align/* = -1*/)
{
    ImGuiWindow* window = GetCurrentWindow();
    BeginLayout(window->GetID(str_id), ImGuiLayoutType_Vertical, size, align);
}

void BeginVertical(const void* ptr_id, const ImVec2& size/* = ImVec2(0, 0)*/, float align/* = -1*/)
{
    ImGuiWindow* window = GetCurrentWindow();
    BeginLayout(window->GetID(ptr_id), ImGuiLayoutType_Vertical, size, align);
}

void BeginVertical(int id, const ImVec2& size/* = ImVec2(0, 0)*/, float align/* = -1*/)
{
    ImGuiWindow* window = GetCurrentWindow();
    BeginLayout(window->GetID((void*)(intptr_t)id), ImGuiLayoutType_Vertical, size, align);
}

void EndVertical()
{
    EndLayout(ImGuiLayoutType_Vertical);
}

// Inserts spring separator in layout
//      weight <= 0     : spring will always have zero size
//      weight > 0      : power of current spring
//      spacing < 0     : use default spacing if pos_x == 0, no spacing if pos_x != 0
//      spacing >= 0    : enforce spacing amount
void Spring(float weight/* = 1.0f*/, float spacing/* = -1.0f*/)
{
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(window->DC.CurrentLayout);

    AddLayoutSpring(*window->DC.CurrentLayout, weight, spacing);
}

void SuspendLayout()
{
    PushLayout(NULL);
}

void ResumeLayout()
{
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(!window->DC.CurrentLayout);
    IM_ASSERT(!window->DC.LayoutStack.empty());
    PopLayout(NULL);
}
} // namespace ImGui